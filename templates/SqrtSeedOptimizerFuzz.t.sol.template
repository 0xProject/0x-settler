// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {uint512, alloc} from "src/utils/512Math.sol";
import {SlowMath} from "./SlowMath.sol";
import {Test} from "@forge-std/Test.sol";
import {Clz} from "src/vendor/Clz.sol";
import {console} from "@forge-std/console.sol";

// This is a template contract that will be generated by the Python script
// with specific BUCKET, SEED, and THRESHOLD values
contract SqrtSeedOptimizerFuzz is Test {
    // These constants will be replaced by the Python script
    uint256 constant BUCKET = ${BUCKET};
    uint256 constant SEED = ${SEED};
    uint256 constant INV_E_THRESHOLD = ${INV_E_THRESHOLD};

    function testFuzz_sqrt_seed(uint256 x_hi_raw, bool x_lo_raw) external pure {
        // Transform raw inputs to force specific invE and bucket
        (uint256 x_hi, uint256 x_lo) = transformInputForBucketAndThreshold(
            x_hi_raw,
            x_lo_raw,
            BUCKET,
            INV_E_THRESHOLD
        );

        // Skip if transformation resulted in invalid input
        vm.assume(x_hi != 0);

        // Verify the transformed input has correct invE and bucket
        (uint256 actualInvE, uint256 actualBucket) = calculateInvEAndBucket(x_hi, x_lo);

        // Skip if we couldn't achieve the target invE and bucket
        if (actualInvE != INV_E_THRESHOLD || actualBucket != BUCKET) {
            return;
        }

        // Test the sqrt function with the given seed
        uint512 x = alloc().from(x_hi, x_lo);
        uint256 r = x.sqrt(BUCKET, SEED, INV_E_THRESHOLD);

        // Verify: r^2 <= x < (r+1)^2
        (uint256 r2_lo, uint256 r2_hi) = SlowMath.fullMul(r, r);

        // Check r^2 <= x
        bool lower_ok = (r2_hi < x_hi) || (r2_hi == x_hi && r2_lo <= x_lo);
        require(lower_ok, "sqrt too high");

        // Check x < (r+1)^2
        if (r == type(uint256).max) {
            // Handle overflow case
            bool at_threshold = x_hi > 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe
                || (x_hi == 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe && x_lo != 0);
            require(at_threshold, "sqrt too low (overflow)");
        } else {
            uint256 r1 = r + 1;
            (uint256 r1_2_lo, uint256 r1_2_hi) = SlowMath.fullMul(r1, r1);
            bool upper_ok = (r1_2_hi > x_hi) || (r1_2_hi == x_hi && r1_2_lo > x_lo);
            require(upper_ok, "sqrt too low");
        }
    }

    function transformInputForBucketAndThreshold(
        uint256 x_hi_raw,
        bool x_lo_raw,
        uint256 targetBucket,
        uint256 targetInvE
    ) internal pure returns (uint256 x_hi, uint256 x_lo) {
        // The mantissa extraction shift is: shift = 257 - 2*invE
        uint256 shift = 257 - (targetInvE * 2);

        // Special case: if invE is too large, shift becomes negative
        if (shift > 256) {
            return (0, 0);
        }

        // Construct mantissa M with targetBucket in top 6 bits
        // M should be in range [targetBucket * 2^250, (targetBucket+1) * 2^250)
        uint256 M = targetBucket << 250;

        // Use the raw inputs as entropy for the lower bits of M
        // This gives us variation within the bucket
        uint256 entropy = x_hi_raw & ((1 << 250) - 1);
        M = M | entropy;

        // Now we need to transform M back to x
        // x = M << shift (in 512-bit arithmetic)
        require(shift > 0 && shift < 256);
        x_hi = M >> (256 - shift);
        x_lo = (M << shift) | ((x_lo_raw ? type(uint256).max : 0) >> (256 - shift));
    }

    function calculateInvEAndBucket(uint256 x_hi, uint256 x_lo)
        internal pure returns (uint256 invE, uint256 bucket)
    {
        // Count leading zeros
        uint256 clz = Clz.clz(x_hi);

        // Calculate invE = (clz + 1) >> 1
        invE = (clz + 1) >> 1;

        // Calculate shift for mantissa extraction
        uint256 shift = 257 - (invE * 2);

        // Extract mantissa M by shifting x right
        uint256 M;
        if (shift == 0) {
            M = x_hi;
        } else if (shift < 256) {
            // Combine parts from x_hi and x_lo
            M = (x_hi << (256 - shift)) | (x_lo >> shift);
        } else {
            // Shift >= 256, M comes entirely from x_lo
            M = x_lo >> (shift - 256);
        }

        // Extract bucket from top 6 bits of M
        bucket = (M >> 250) & 0x3F;
    }
}