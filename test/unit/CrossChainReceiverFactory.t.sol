// SPDX-License-Identifier: MIT
pragma solidity ^0.8.33;

import {IERC20} from "@forge-std/interfaces/IERC20.sol";
import {IERC165} from "@forge-std/interfaces/IERC165.sol";

import {IMultiCall, EIP150_MULTICALL_ADDRESS} from "src/multicall/MultiCallContext.sol";
import {IOwnable} from "src/interfaces/IOwnable.sol";

import {Test} from "@forge-std/Test.sol";
import {VmSafe} from "@forge-std/Vm.sol";
import {ICrossChainReceiverFactory} from "src/interfaces/ICrossChainReceiverFactory.sol";
import {CrossChainReceiverFactory, IWrappedNative} from "src/CrossChainReceiverFactory.sol";

/// @notice Extended interface for two-step ownership functions not exposed in ICrossChainReceiverFactory
interface ITwoStepOwnable {
    event OwnershipPending(address indexed newOwner);

    function pendingOwner() external view returns (address);
    function acceptOwnership() external returns (bool);
    function rejectOwnership() external returns (bool);
    function renounceOwnership() external returns (bool);
}

/// @notice Mock contract that receives ETH and echoes back the input value
/// @dev Used for testing the patching call functionality
contract MockTarget {
    // Receive function to accept ETH transfers
    receive() external payable {}

    // Echo function that returns its input - used to verify patched bytes
    function echo(uint256 value) external payable returns (uint256) {
        return value;
    }
}

/// @title CrossChainReceiverFactory Test Suite
/// @notice Comprehensive tests for CrossChainReceiverFactory
/// @dev Tests organized according to CROSSCHAIN_RECEIVER_COVERAGE.md
contract CrossChainReceiverFactoryTest is Test {
    // =========================================================================
    // CONSTANTS
    // =========================================================================

    // Factory deployed in setUp() (vanity address keeps proxy initcode intact)
    ICrossChainReceiverFactory internal factory;

    IERC20 internal constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    // TOEHOLD is the deterministic deployer that the constructor expects as msg.sender
    address internal constant TOEHOLD = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
    address internal constant STORAGE_SETTER = 0x000000000000F01B1D1c8EEF6c6cF71a0b658Fbc;

    // Permit2 address
    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;

    // Native token sentinel address
    address internal constant NATIVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    IERC20 internal constant NATIVE = IERC20(NATIVE_ADDRESS);

    // EIP-712 type hashes
    bytes32 internal constant DOMAIN_TYPEHASH =
        keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
    bytes32 internal constant NAMEHASH = keccak256("ZeroExCrossChainReceiver");
    bytes32 internal constant MULTICALL_TYPEHASH = keccak256(
        "MultiCall(Call[] calls,uint256 contextdepth,uint256 nonce,uint256 deadline)Call(address target,uint8 revertPolicy,uint256 value,bytes data)"
    );
    bytes32 internal constant CALL_TYPEHASH =
        keccak256("Call(address target,uint8 revertPolicy,uint256 value,bytes data)");

    // ERC-1271 magic values
    bytes4 internal constant MAGIC_VALUE = 0x1626ba7e;
    bytes4 internal constant INVALID_SIG = 0xffffffff;

    // ERC7739 magic value for empty sig check
    bytes32 internal constant ERC7739_MAGIC_HASH =
        0x7739773977397739773977397739773977397739773977397739773977397739;

    // Sentinel value for breaking circular hash dependencies in Merkle mode
    address internal constant ADDRESS_THIS_SENTINEL = 0x0000000000000061646472657373287468697329;

    // Domain separator for Merkle mode (uses sentinel instead of actual proxy address, omits chainId)
    bytes32 internal constant MERKLE_DOMAIN_TYPEHASH =
        keccak256("EIP712Domain(string name,address verifyingContract)");
    bytes32 internal constant SENTINEL_DOMAIN_SEPARATOR =
        0x645883bdca79cf2f0cd9e1ce41a5e705279b61c531a89508da475b856926949a;

    // Missing WNATIVE bytecode: 0x30ff followed by 30 zero bytes
    // When interpreted: bytes32 -> uint256 -> uint160 -> address gives address(0)
    // Codehash: 0xa4675c945174b9ec4e7010035cbc327beed918e1ea949cf630df20b201167a0c
    bytes internal constant MISSING_WNATIVE_BYTECODE =
        hex"30ff000000000000000000000000000000000000000000000000000000000000";
    bytes32 internal constant MISSING_WNATIVE_CODEHASH =
        0xa4675c945174b9ec4e7010035cbc327beed918e1ea949cf630df20b201167a0c;

    // Factory address for missing WNATIVE chain tests (must have 7 leading null bytes)
    ICrossChainReceiverFactory internal constant missingWnativeFactory =
        ICrossChainReceiverFactory(payable(0x00000000000000AaBbCcDdEEfF11223344556677));
    // Factory address for regular tests (must have 7 leading null bytes)
    ICrossChainReceiverFactory internal constant vanityFactory =
        ICrossChainReceiverFactory(payable(0x00000000000000CCddEEff001122334455667788));
    // =========================================================================
    // STATE VARIABLES
    // =========================================================================

    address internal wnativeStorage;
    uint256 internal defaultOwnerKey = uint256(keccak256(abi.encode("default_owner")));
    address internal defaultOwner;

    // =========================================================================
    // SETUP
    // =========================================================================

    function setUp() public {
        defaultOwner = vm.addr(defaultOwnerKey);

        vm.etch(
            address(WETH),
            hex"6060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029"
        );

        vm.etch(
            PERMIT2,
            hex"6040608081526004908136101561001557600080fd5b600090813560e01c80630d58b1db1461126c578063137c29fe146110755780632a2d80d114610db75780632b67b57014610bde57806330f28b7a14610ade5780633644e51514610a9d57806336c7851614610a285780633ff9dcb1146109a85780634fe02b441461093f57806365d9723c146107ac57806387517c451461067a578063927da105146105c3578063cc53287f146104a3578063edd9444b1461033a5763fe8ec1a7146100c657600080fd5b346103365760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103365767ffffffffffffffff833581811161033257610114903690860161164b565b60243582811161032e5761012b903690870161161a565b6101336114e6565b9160843585811161032a5761014b9036908a016115c1565b98909560a43590811161032657610164913691016115c1565b969095815190610173826113ff565b606b82527f5065726d697442617463685769746e6573735472616e7366657246726f6d285460208301527f6f6b656e5065726d697373696f6e735b5d207065726d69747465642c61646472838301527f657373207370656e6465722c75696e74323536206e6f6e63652c75696e74323560608301527f3620646561646c696e652c000000000000000000000000000000000000000000608083015282519a8b9181610222602085018096611f93565b918237018a8152039961025b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09b8c8101835282611437565b5190209085515161026b81611ebb565b908a5b8181106102f95750506102f6999a6102ed9183516102a081610294602082018095611f66565b03848101835282611437565b519020602089810151858b015195519182019687526040820192909252336060820152608081019190915260a081019390935260643560c08401528260e081015b03908101835282611437565b51902093611cf7565b80f35b8061031161030b610321938c5161175e565b51612054565b61031b828661175e565b52611f0a565b61026e565b8880fd5b8780fd5b8480fd5b8380fd5b5080fd5b5091346103365760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103365767ffffffffffffffff9080358281116103325761038b903690830161164b565b60243583811161032e576103a2903690840161161a565b9390926103ad6114e6565b9160643590811161049f576103c4913691016115c1565b949093835151976103d489611ebb565b98885b81811061047d5750506102f697988151610425816103f9602082018095611f66565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282611437565b5190206020860151828701519083519260208401947ffcf35f5ac6a2c28868dc44c302166470266239195f02b0ee408334829333b7668652840152336060840152608083015260a082015260a081526102ed8161141b565b808b61031b8261049461030b61049a968d5161175e565b9261175e565b6103d7565b8680fd5b5082346105bf57602090817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103325780359067ffffffffffffffff821161032e576104f49136910161161a565b929091845b848110610504578580f35b8061051a610515600193888861196c565b61197c565b61052f84610529848a8a61196c565b0161197c565b3389528385528589209173ffffffffffffffffffffffffffffffffffffffff80911692838b528652868a20911690818a5285528589207fffffffffffffffffffffffff000000000000000000000000000000000000000081541690558551918252848201527f89b1add15eff56b3dfe299ad94e01f2b52fbcb80ae1a3baea6ae8c04cb2b98a4853392a2016104f9565b8280fd5b50346103365760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657610676816105ff6114a0565b936106086114c3565b6106106114e6565b73ffffffffffffffffffffffffffffffffffffffff968716835260016020908152848420928816845291825283832090871683528152919020549251938316845260a083901c65ffffffffffff169084015260d09190911c604083015281906060820190565b0390f35b50346103365760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610336576106b26114a0565b906106bb6114c3565b916106c46114e6565b65ffffffffffff926064358481169081810361032a5779ffffffffffff0000000000000000000000000000000000000000947fda9fa7c1b00402c17d0161b249b1ab8bbec047c5a52207b9c112deffd817036b94338a5260016020527fffffffffffff0000000000000000000000000000000000000000000000000000858b209873ffffffffffffffffffffffffffffffffffffffff809416998a8d5260205283878d209b169a8b8d52602052868c209486156000146107a457504216925b8454921697889360a01b16911617179055815193845260208401523392a480f35b905092610783565b5082346105bf5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf576107e56114a0565b906107ee6114c3565b9265ffffffffffff604435818116939084810361032a57338852602091600183528489209673ffffffffffffffffffffffffffffffffffffffff80911697888b528452858a20981697888a5283528489205460d01c93848711156109175761ffff9085840316116108f05750907f55eb90d810e1700b35a8e7e25395ff7f2b2259abd7415ca2284dfb1c246418f393929133895260018252838920878a528252838920888a5282528389209079ffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffff000000000000000000000000000000000000000000000000000083549260d01b16911617905582519485528401523392a480f35b84517f24d35a26000000000000000000000000000000000000000000000000000000008152fd5b5084517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b503461033657807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610336578060209273ffffffffffffffffffffffffffffffffffffffff61098f6114a0565b1681528084528181206024358252845220549051908152f35b5082346105bf57817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf577f3704902f963766a4e561bbaab6e6cdc1b1dd12f6e9e99648da8843b3f46b918d90359160243533855284602052818520848652602052818520818154179055815193845260208401523392a280f35b8234610a9a5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610a9a57610a606114a0565b610a686114c3565b610a706114e6565b6064359173ffffffffffffffffffffffffffffffffffffffff8316830361032e576102f6936117a1565b80fd5b503461033657817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657602090610ad7611b1e565b9051908152f35b508290346105bf576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf57610b1a3661152a565b90807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7c36011261033257610b4c611478565b9160e43567ffffffffffffffff8111610bda576102f694610b6f913691016115c1565b939092610b7c8351612054565b6020840151828501519083519260208401947f939c21a48a8dbe3a9a2404a1d46691e4d39f6583d6ec6b35714604c986d801068652840152336060840152608083015260a082015260a08152610bd18161141b565b51902091611c25565b8580fd5b509134610336576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657610c186114a0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc360160c08112610332576080855191610c51836113e3565b1261033257845190610c6282611398565b73ffffffffffffffffffffffffffffffffffffffff91602435838116810361049f578152604435838116810361049f57602082015265ffffffffffff606435818116810361032a5788830152608435908116810361049f576060820152815260a435938285168503610bda576020820194855260c4359087830182815260e43567ffffffffffffffff811161032657610cfe90369084016115c1565b929093804211610d88575050918591610d786102f6999a610d7e95610d238851611fbe565b90898c511690519083519260208401947ff3841cd1ff0085026a6327b620b67997ce40f282c88a8e905a7a5626e310f3d086528401526060830152608082015260808152610d70816113ff565b519020611bd9565b916120c7565b519251169161199d565b602492508a51917fcd21db4f000000000000000000000000000000000000000000000000000000008352820152fd5b5091346103365760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc93818536011261033257610df36114a0565b9260249081359267ffffffffffffffff9788851161032a578590853603011261049f578051978589018981108282111761104a578252848301358181116103265785019036602383011215610326578382013591610e50836115ef565b90610e5d85519283611437565b838252602093878584019160071b83010191368311611046578801905b828210610fe9575050508a526044610e93868801611509565b96838c01978852013594838b0191868352604435908111610fe557610ebb90369087016115c1565b959096804211610fba575050508998995151610ed681611ebb565b908b5b818110610f9757505092889492610d7892610f6497958351610f02816103f98682018095611f66565b5190209073ffffffffffffffffffffffffffffffffffffffff9a8b8b51169151928551948501957faf1b0d30d2cab0380e68f0689007e3254993c596f2fdd0aaa7f4d04f794408638752850152830152608082015260808152610d70816113ff565b51169082515192845b848110610f78578580f35b80610f918585610f8b600195875161175e565b5161199d565b01610f6d565b80610311610fac8e9f9e93610fb2945161175e565b51611fbe565b9b9a9b610ed9565b8551917fcd21db4f000000000000000000000000000000000000000000000000000000008352820152fd5b8a80fd5b6080823603126110465785608091885161100281611398565b61100b85611509565b8152611018838601611509565b838201526110278a8601611607565b8a8201528d611037818701611607565b90820152815201910190610e7a565b8c80fd5b84896041867f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b5082346105bf576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf576110b03661152a565b91807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7c360112610332576110e2611478565b67ffffffffffffffff93906101043585811161049f5761110590369086016115c1565b90936101243596871161032a57611125610bd1966102f6983691016115c1565b969095825190611134826113ff565b606482527f5065726d69745769746e6573735472616e7366657246726f6d28546f6b656e5060208301527f65726d697373696f6e73207065726d69747465642c6164647265737320737065848301527f6e6465722c75696e74323536206e6f6e63652c75696e7432353620646561646c60608301527f696e652c0000000000000000000000000000000000000000000000000000000060808301528351948591816111e3602085018096611f93565b918237018b8152039361121c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe095868101835282611437565b5190209261122a8651612054565b6020878101518589015195519182019687526040820192909252336060820152608081019190915260a081019390935260e43560c08401528260e081016102e1565b5082346105bf576020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033257813567ffffffffffffffff92838211610bda5736602383011215610bda5781013592831161032e576024906007368386831b8401011161049f57865b8581106112e5578780f35b80821b83019060807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc83360301126103265761139288876001946060835161132c81611398565b611368608461133c8d8601611509565b9485845261134c60448201611509565b809785015261135d60648201611509565b809885015201611509565b918291015273ffffffffffffffffffffffffffffffffffffffff80808093169516931691166117a1565b016112da565b6080810190811067ffffffffffffffff8211176113b457604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6060810190811067ffffffffffffffff8211176113b457604052565b60a0810190811067ffffffffffffffff8211176113b457604052565b60c0810190811067ffffffffffffffff8211176113b457604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176113b457604052565b60c4359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b600080fd5b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b6044359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01906080821261149b576040805190611563826113e3565b8082941261149b57805181810181811067ffffffffffffffff8211176113b457825260043573ffffffffffffffffffffffffffffffffffffffff8116810361149b578152602435602082015282526044356020830152606435910152565b9181601f8401121561149b5782359167ffffffffffffffff831161149b576020838186019501011161149b57565b67ffffffffffffffff81116113b45760051b60200190565b359065ffffffffffff8216820361149b57565b9181601f8401121561149b5782359167ffffffffffffffff831161149b576020808501948460061b01011161149b57565b91909160608184031261149b576040805191611666836113e3565b8294813567ffffffffffffffff9081811161149b57830182601f8201121561149b578035611693816115ef565b926116a087519485611437565b818452602094858086019360061b8501019381851161149b579086899897969594939201925b8484106116e3575050505050855280820135908501520135910152565b90919293949596978483031261149b578851908982019082821085831117611730578a928992845261171487611509565b81528287013583820152815201930191908897969594936116c6565b602460007f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b80518210156117725760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b92919273ffffffffffffffffffffffffffffffffffffffff604060008284168152600160205282828220961695868252602052818120338252602052209485549565ffffffffffff8760a01c16804211611884575082871696838803611812575b5050611810955016926118b5565b565b878484161160001461184f57602488604051907ff96fb0710000000000000000000000000000000000000000000000000000000082526004820152fd5b7fffffffffffffffffffffffff000000000000000000000000000000000000000084846118109a031691161790553880611802565b602490604051907fd81b2f2e0000000000000000000000000000000000000000000000000000000082526004820152fd5b9060006064926020958295604051947f23b872dd0000000000000000000000000000000000000000000000000000000086526004860152602485015260448401525af13d15601f3d116001600051141617161561190e57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152fd5b91908110156117725760061b0190565b3573ffffffffffffffffffffffffffffffffffffffff8116810361149b5790565b9065ffffffffffff908160608401511673ffffffffffffffffffffffffffffffffffffffff908185511694826020820151169280866040809401511695169560009187835260016020528383208984526020528383209916988983526020528282209184835460d01c03611af5579185611ace94927fc6a377bfc4eb120024a8ac08eef205be16b817020812c73223e81d1bdb9708ec98979694508715600014611ad35779ffffffffffff00000000000000000000000000000000000000009042165b60a01b167fffffffffffff00000000000000000000000000000000000000000000000000006001860160d01b1617179055519384938491604091949373ffffffffffffffffffffffffffffffffffffffff606085019616845265ffffffffffff809216602085015216910152565b0390a4565b5079ffffffffffff000000000000000000000000000000000000000087611a60565b600484517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b467f000000000000000000000000000000000000000000000000000000000000000103611b69577f866a5aba21966af95d6c7ab78eb2b2fc913915c28be3b9aa07cc04ff903e3f2890565b60405160208101907f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86682527f9ac997416e8ff9d2ff6bebeb7149f65cdae5e32e2b90440b566bb3044041d36a604082015246606082015230608082015260808152611bd3816113ff565b51902090565b611be1611b1e565b906040519060208201927f190100000000000000000000000000000000000000000000000000000000000084526022830152604282015260428152611bd381611398565b9192909360a435936040840151804211611cc65750602084510151808611611c955750918591610d78611c6594611c60602088015186611e47565b611bd9565b73ffffffffffffffffffffffffffffffffffffffff809151511692608435918216820361149b57611810936118b5565b602490604051907f3728b83d0000000000000000000000000000000000000000000000000000000082526004820152fd5b602490604051907fcd21db4f0000000000000000000000000000000000000000000000000000000082526004820152fd5b959093958051519560409283830151804211611e175750848803611dee57611d2e918691610d7860209b611c608d88015186611e47565b60005b868110611d42575050505050505050565b611d4d81835161175e565b5188611d5a83878a61196c565b01359089810151808311611dbe575091818888886001968596611d84575b50505050505001611d31565b611db395611dad9273ffffffffffffffffffffffffffffffffffffffff6105159351169561196c565b916118b5565b803888888883611d78565b6024908651907f3728b83d0000000000000000000000000000000000000000000000000000000082526004820152fd5b600484517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b6024908551907fcd21db4f0000000000000000000000000000000000000000000000000000000082526004820152fd5b9073ffffffffffffffffffffffffffffffffffffffff600160ff83161b9216600052600060205260406000209060081c6000526020526040600020818154188091551615611e9157565b60046040517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b90611ec5826115ef565b611ed26040519182611437565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611f0082946115ef565b0190602036910137565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114611f375760010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b805160208092019160005b828110611f7f575050505090565b835185529381019392810192600101611f71565b9081519160005b838110611fab575050016000815290565b8060208092840101518185015201611f9a565b60405160208101917f65626cad6cb96493bf6f5ebea28756c966f023ab9e8a83a7101849d5573b3678835273ffffffffffffffffffffffffffffffffffffffff8082511660408401526020820151166060830152606065ffffffffffff9182604082015116608085015201511660a082015260a0815260c0810181811067ffffffffffffffff8211176113b45760405251902090565b6040516020808201927f618358ac3db8dc274f0cd8829da7e234bd48cd73c4a740aede1adec9846d06a1845273ffffffffffffffffffffffffffffffffffffffff81511660408401520151606082015260608152611bd381611398565b919082604091031261149b576020823592013590565b6000843b61222e5750604182036121ac576120e4828201826120b1565b939092604010156117725760209360009360ff6040608095013560f81c5b60405194855216868401526040830152606082015282805260015afa156121a05773ffffffffffffffffffffffffffffffffffffffff806000511691821561217657160361214c57565b60046040517f815e1d64000000000000000000000000000000000000000000000000000000008152fd5b60046040517f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b6040513d6000823e3d90fd5b60408203612204576121c0918101906120b1565b91601b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84169360ff1c019060ff8211611f375760209360009360ff608094612102565b60046040517f4be6321b000000000000000000000000000000000000000000000000000000008152fd5b929391601f928173ffffffffffffffffffffffffffffffffffffffff60646020957fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0604051988997889687947f1626ba7e000000000000000000000000000000000000000000000000000000009e8f8752600487015260406024870152816044870152868601378b85828601015201168101030192165afa9081156123a857829161232a575b507fffffffff000000000000000000000000000000000000000000000000000000009150160361230057565b60046040517fb0669cbc000000000000000000000000000000000000000000000000000000008152fd5b90506020813d82116123a0575b8161234460209383611437565b810103126103365751907fffffffff0000000000000000000000000000000000000000000000000000000082168203610a9a57507fffffffff0000000000000000000000000000000000000000000000000000000090386122d4565b3d9150612337565b6040513d84823e3d90fdfea164736f6c6343000811000a"
        );
        vm.label(PERMIT2, "Permit2");

        IMultiCall multicall = IMultiCall(payable(EIP150_MULTICALL_ADDRESS));
        deployCodeTo("MultiCall.sol:MultiCall", "", 0, address(multicall));
        require(address(multicall).code.length != 0, "MultiCall has no code");

        bytes memory storageInitcode =
            hex"326df01b1d1c8eef6c6cf71a0b658fbc1815601657fe5b7f60143603803560601c6df01b1d1c8eef6c6cf71a0b658fbc14336ccf9e3c5a263d527f621af382fa17f24f1416602e57fe5b3d54604b57583d55803d3d373d34f03d8159526d6045573dfd5b5260203df35b30ff60901b5952604e3df3";
        bytes32 wnativeStorageSalt = keccak256("Wrapped Native Token Address");
        bytes32 multicallStorageSalt = keccak256("ERC2771-forwarding MultiCall Address");

        vm.prank(STORAGE_SETTER, STORAGE_SETTER);
        (bool success, bytes memory returndata) = TOEHOLD.call(bytes.concat(wnativeStorageSalt, storageInitcode));
        require(success, "Shim deployment failed");
        require(returndata.length == 20, "Shim deployment returned wrong size");
        address wnativeShim = address(uint160(bytes20(returndata)));
        vm.label(wnativeShim, "wrapped native address storage shim");
        wnativeStorage =
            address(uint160(uint256(keccak256(bytes.concat(bytes2(0xd694), bytes20(uint160(wnativeShim)), bytes1(0x01))))));
        vm.label(wnativeStorage, "wrapped native address storage");

        vm.prank(STORAGE_SETTER, STORAGE_SETTER);
        (success, returndata) = TOEHOLD.call(bytes.concat(multicallStorageSalt, storageInitcode));
        require(success, "Multicall shim deployment failed");
        require(returndata.length == 20, "Multicall shim deployment returned wrong size");
        address multicallShim = address(uint160(bytes20(returndata)));
        vm.label(multicallShim, "multicall address storage shim");
        address multicallStorage = address(
            uint160(uint256(keccak256(bytes.concat(bytes2(0xd694), bytes20(uint160(multicallShim)), bytes1(0x01)))))
        );
        vm.label(multicallStorage, "multicall address storage");

        vm.prank(STORAGE_SETTER);
        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = wnativeShim;
        calls[0].data = bytes.concat(hex"7f30ff00000000000000000000", bytes20(uint160(address(WETH))), hex"5f52595ff3");
        multicall.multicall(calls, 0);
        require(wnativeStorage.code.length != 0, "wnativeStorage has no code");

        vm.prank(STORAGE_SETTER);
        IMultiCall.Call[] memory multicallCalls = new IMultiCall.Call[](1);
        multicallCalls[0].target = multicallShim;
        multicallCalls[0].data =
            bytes.concat(hex"7f30ff00000000000000000000", bytes20(uint160(EIP150_MULTICALL_ADDRESS)), hex"5f52595ff3");
        multicall.multicall(multicallCalls, 0);
        require(multicallStorage.code.length != 0, "multicallStorage has no code");

        // Deploy to a 13-byte address so proxy initcode stays valid.
        vm.chainId(31337);
        vm.setNonce(address(vanityFactory), 1);
        vm.deal(TOEHOLD, 2 wei);
        vm.startPrank(TOEHOLD);
        deployCodeTo("CrossChainReceiverFactory.sol", "", 2 wei, address(vanityFactory));
        vm.stopPrank();

        factory = vanityFactory;
        vm.label(address(factory), "CrossChainReceiverFactory");
    }

    // =========================================================================
    // HELPER FUNCTIONS - Proxy Deployment
    // =========================================================================

    /// @notice Deploy a proxy with a given Merkle root
    /// @param root The Merkle root used as part of the CREATE2 salt
    /// @param privateKey The private key of the owner
    /// @param setOwner If true, calls setOwner; if false, calls cleanup
    /// @return proxy The deployed proxy
    /// @return owner The owner address derived from privateKey
    function _deployProxyToRoot(bytes32 root, uint256 privateKey, bool setOwner)
        internal
        returns (ICrossChainReceiverFactory proxy, address owner)
    {
        owner = vm.addr(privateKey);
        proxy = factory.deploy(root, setOwner, owner);
        vm.label(address(proxy), "Proxy");
    }

    /// @notice Deploy a proxy with a single-leaf Merkle tree from an action hash
    /// @param action The action hash to use as the leaf
    /// @param privateKey The private key of the owner
    /// @param setOwner If true, calls setOwner; if false, calls cleanup
    function _deployProxy(bytes32 action, uint256 privateKey, bool setOwner)
        internal
        returns (ICrossChainReceiverFactory, address)
    {
        bytes32 root = _hashLeaf(action);
        return _deployProxyToRoot(root, privateKey, setOwner);
    }

    /// @notice Deploy a proxy with setOwner=true
    function _deployProxy(bytes32 action, uint256 privateKey) internal returns (ICrossChainReceiverFactory, address) {
        return _deployProxy(action, privateKey, true);
    }

    /// @notice Deploy a proxy with default owner
    function _deployProxy(bytes32 action) internal returns (ICrossChainReceiverFactory, address) {
        return _deployProxy(action, defaultOwnerKey);
    }

    /// @notice Deploy a proxy with a two-leaf Merkle tree
    /// @param action1 First action hash
    /// @param action2 Second action hash
    /// @param privateKey The private key of the owner
    /// @param setOwner If true, calls setOwner
    function _deployProxyTwoLeaves(bytes32 action1, bytes32 action2, uint256 privateKey, bool setOwner)
        internal
        returns (ICrossChainReceiverFactory proxy, address owner, bytes32 root, bytes32 leaf1, bytes32 leaf2)
    {
        leaf1 = _hashLeaf(action1);
        leaf2 = _hashLeaf(action2);
        if (leaf2 < leaf1) {
            root = keccak256(abi.encodePacked(leaf2, leaf1));
        } else {
            root = keccak256(abi.encodePacked(leaf1, leaf2));
        }
        (proxy, owner) = _deployProxyToRoot(root, privateKey, setOwner);
    }

    // =========================================================================
    // HELPER FUNCTIONS - Missing WNATIVE Factory
    // =========================================================================

    /// @notice Deploy a factory configured for chains without WNATIVE (WNATIVE == address(0))
    /// @dev Temporarily replaces wnativeStorage bytecode with MISSING_WNATIVE_BYTECODE,
    ///      deploys the factory, then restores original bytecode for test isolation.
    function _deployMissingWnativeFactory() internal {
        bytes memory originalWnativeCode = wnativeStorage.code;

        vm.etch(wnativeStorage, MISSING_WNATIVE_BYTECODE);

        require(wnativeStorage.codehash == MISSING_WNATIVE_CODEHASH, "Missing WNATIVE codehash mismatch");

        vm.chainId(31337);
        // Ensure deterministic CREATE address for the factory.
        vm.setNonce(address(missingWnativeFactory), 1);
        vm.startPrank(TOEHOLD);
        deployCodeTo("CrossChainReceiverFactory.sol", "", 0, address(missingWnativeFactory));
        vm.stopPrank();

        vm.etch(wnativeStorage, originalWnativeCode);
    }

    /// @notice Deploy a proxy using the missing WNATIVE factory
    /// @param root The Merkle root for CREATE2 salt
    /// @param privateKey The private key of the owner
    /// @param setOwner If true, calls setOwner (forced to true when _MISSING_WNATIVE=true)
    /// @return proxy The deployed proxy
    /// @return owner The owner address
    function _deployProxyMissingWnative(bytes32 root, uint256 privateKey, bool setOwner)
        internal
        returns (ICrossChainReceiverFactory proxy, address owner)
    {
        owner = vm.addr(privateKey);
        proxy = missingWnativeFactory.deploy(root, setOwner, owner);
        vm.label(address(proxy), "ProxyMissingWNATIVE");
    }

    // =========================================================================
    // HELPER FUNCTIONS - Merkle Tree
    // =========================================================================

    /// @notice Hash a signing hash into a leaf (includes chainid for replay protection)
    function _hashLeaf(bytes32 signingHash) internal view returns (bytes32) {
        return keccak256(abi.encode(signingHash, block.chainid));
    }

    /// @notice Compute Merkle root from a proof and leaf
    function _getMerkleRoot(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (proofElement < computedHash) {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            } else {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            }
        }
        return computedHash;
    }

    /// @notice Build a Merkle tree from an array of leaves and return root + proofs
    /// @dev Supports up to 8 leaves for simplicity
    function _buildMerkleTree(bytes32[] memory leaves)
        internal
        pure
        returns (bytes32 root, bytes32[][] memory proofs)
    {
        require(leaves.length > 0, "Empty leaves");
        proofs = new bytes32[][](leaves.length);

        if (leaves.length == 1) {
            root = leaves[0];
            proofs[0] = new bytes32[](0);
            return (root, proofs);
        }

        // For 2 leaves
        if (leaves.length == 2) {
            bytes32 left = leaves[0];
            bytes32 right = leaves[1];
            if (right < left) {
                (left, right) = (right, left);
            }
            root = keccak256(abi.encodePacked(left, right));
            proofs[0] = new bytes32[](1);
            proofs[0][0] = leaves[1];
            proofs[1] = new bytes32[](1);
            proofs[1][0] = leaves[0];
            return (root, proofs);
        }

        // For more leaves, pad to power of 2 and build tree
        uint256 n = 1;
        while (n < leaves.length) {
            n *= 2;
        }
        bytes32[] memory tree = new bytes32[](2 * n);
        for (uint256 i = 0; i < leaves.length; i++) {
            tree[n + i] = leaves[i];
        }
        // Duplicate last leaf if needed
        for (uint256 i = leaves.length; i < n; i++) {
            tree[n + i] = leaves[leaves.length - 1];
        }
        // Build tree bottom-up
        for (uint256 i = n - 1; i >= 1; i--) {
            bytes32 left = tree[2 * i];
            bytes32 right = tree[2 * i + 1];
            if (right < left) {
                tree[i] = keccak256(abi.encodePacked(right, left));
            } else {
                tree[i] = keccak256(abi.encodePacked(left, right));
            }
        }
        root = tree[1];

        // Build proofs
        for (uint256 i = 0; i < leaves.length; i++) {
            uint256 depth = 0;
            uint256 tempN = n;
            while (tempN > 1) {
                depth++;
                tempN /= 2;
            }
            proofs[i] = new bytes32[](depth);
            uint256 idx = n + i;
            for (uint256 d = 0; d < depth; d++) {
                uint256 sibling = idx ^ 1;
                proofs[i][d] = tree[sibling];
                idx /= 2;
            }
        }
    }

    // =========================================================================
    // HELPER FUNCTIONS - EIP-712 Hashing
    // =========================================================================

    /// @notice Compute the EIP-712 domain separator for a proxy
    function _computeDomainSeparator(address proxy) internal view returns (bytes32) {
        return keccak256(abi.encode(DOMAIN_TYPEHASH, NAMEHASH, block.chainid, proxy));
    }

    /// @notice Hash a struct for EIP-712 signing
    function _hashEip712(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(hex"1901", domainSeparator, structHash));
    }

    /// @notice Hash a Call struct for MultiCall
    function _hashCall(IMultiCall.Call memory call) internal pure returns (bytes32) {
        return keccak256(
            abi.encode(CALL_TYPEHASH, call.target, uint8(call.revertPolicy), call.value, keccak256(call.data))
        );
    }

    /// @notice Hash an array of Call structs
    function _hashCallArray(IMultiCall.Call[] memory calls) internal pure returns (bytes32) {
        bytes32[] memory callHashes = new bytes32[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            callHashes[i] = _hashCall(calls[i]);
        }
        return keccak256(abi.encodePacked(callHashes));
    }

    /// @notice Hash a MultiCall struct for signing
    function _hashMultiCall(IMultiCall.Call[] memory calls, uint256 contextdepth, uint256 nonce, uint256 deadline)
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encode(MULTICALL_TYPEHASH, _hashCallArray(calls), contextdepth, nonce, deadline));
    }

    /// @notice Compute the full signing hash for a metaTx
    function _computeMetaTxSigningHash(
        address proxy,
        IMultiCall.Call[] memory calls,
        uint256 contextdepth,
        uint256 nonce,
        uint256 deadline
    ) internal view returns (bytes32) {
        bytes32 domainSeparator = _computeDomainSeparator(proxy);
        bytes32 structHash = _hashMultiCall(calls, contextdepth, nonce, deadline);
        return _hashEip712(domainSeparator, structHash);
    }

    /// @notice Compute the full signing hash for a metaTx in simple mode
    /// @dev In simple mode (nonce >> 96 == 0), the contract ORs the current owner into the nonce
    ///      before computing the hash. This function replicates that behavior.
    /// @param proxy The proxy address
    /// @param calls The calls array
    /// @param contextdepth The context depth
    /// @param nonce The raw nonce (lower 96 bits only in simple mode)
    /// @param deadline The deadline
    /// @param owner The owner address to include in the nonce
    function _computeMetaTxSigningHashSimpleMode(
        address proxy,
        IMultiCall.Call[] memory calls,
        uint256 contextdepth,
        uint256 nonce,
        uint256 deadline,
        address owner
    ) internal view returns (bytes32) {
        // In simple mode, contract does: nonce |= uint256(uint160(owner_)) << 96
        uint256 modifiedNonce = nonce | (uint256(uint160(owner)) << 96);
        bytes32 domainSeparator = _computeDomainSeparator(proxy);
        bytes32 structHash = _hashMultiCall(calls, contextdepth, modifiedNonce, deadline);
        return _hashEip712(domainSeparator, structHash);
    }

    /// @notice Compute the signing hash for a metaTx in Merkle mode
    /// @dev In Merkle mode (nonce >> 96 != 0), the contract uses a sentinel domain separator
    ///      to break the circular hash dependency. The sentinel domain separator omits chainId
    ///      because the chainId is already included in the leaf hash.
    /// @param calls The calls array
    /// @param contextdepth The context depth
    /// @param nonce The nonce with owner encoded in upper 160 bits
    /// @param deadline The deadline
    function _computeMetaTxSigningHashMerkleMode(
        IMultiCall.Call[] memory calls,
        uint256 contextdepth,
        uint256 nonce,
        uint256 deadline
    ) internal pure returns (bytes32) {
        bytes32 structHash = _hashMultiCall(calls, contextdepth, nonce, deadline);
        return _hashEip712(SENTINEL_DOMAIN_SEPARATOR, structHash);
    }

    // =========================================================================
    // HELPER FUNCTIONS - Signatures
    // =========================================================================

    /// @notice Sign a hash and return ERC-2098 compact signature (r || vs)
    /// @param privateKey The private key to sign with
    /// @param hash The hash to sign
    /// @return signature 64-byte compact signature
    function _signCompact(uint256 privateKey, bytes32 hash) internal pure returns (bytes memory signature) {
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, hash);
        // ERC-2098: vs = (v - 27) << 255 | s
        bytes32 vs = bytes32((uint256(v) - 27) << 255) | s;
        signature = abi.encodePacked(r, vs);
    }

    /// @notice Build a Merkle proof signature for isValidSignature
    /// @param owner The original owner address
    /// @param proof The Merkle proof
    function _buildMerkleProofSignature(address owner, bytes32[] memory proof)
        internal
        pure
        returns (bytes memory signature)
    {
        return abi.encode(owner, proof);
    }

    /// @notice Build an ERC7739 nested typed data signature
    /// @param privateKey Signer's private key
    /// @param proxy The proxy address (verifying contract)
    /// @param appDomainSeparator The application's domain separator
    /// @param contentsHash The hash of the contents struct
    /// @param contentsDescriptor The type descriptor (e.g., "TestData(uint256 a)" for compact mode,
    ///        or "TestData(uint256 a)TestData" for explicit mode)
    function _buildERC7739Signature(
        uint256 privateKey,
        address proxy,
        bytes32 appDomainSeparator,
        bytes32 contentsHash,
        string memory contentsDescriptor
    ) internal view returns (bytes memory signature, bytes32 signedHash) {
        bytes memory desc = bytes(contentsDescriptor);

        // Determine if compact mode (ends with ')') or explicit mode (ends with contentsName)
        bool isCompactMode = desc[desc.length - 1] == ")";

        // For explicit mode, find the rightmost ')' to split contentsType from contentsName
        string memory contentsType;
        bytes memory contentsName;

        if (isCompactMode) {
            // Compact mode: descriptor IS the contentsType
            contentsType = contentsDescriptor;
            // Extract contentsName from the beginning (up to first '(')
            uint256 parenIndex = 0;
            for (uint256 i = 0; i < desc.length; i++) {
                if (desc[i] == "(") {
                    parenIndex = i;
                    break;
                }
            }
            contentsName = new bytes(parenIndex);
            for (uint256 i = 0; i < parenIndex; i++) {
                contentsName[i] = desc[i];
            }
        } else {
            // Explicit mode: descriptor = contentsType + contentsName
            // Scan backward from end to find rightmost ')'
            uint256 lastParenIndex = desc.length;
            for (uint256 i = desc.length; i > 0; i--) {
                if (desc[i - 1] == ")") {
                    lastParenIndex = i; // Position after the ')'
                    break;
                }
            }
            // contentsType is everything up to and including the ')'
            bytes memory typeBytes = new bytes(lastParenIndex);
            for (uint256 i = 0; i < lastParenIndex; i++) {
                typeBytes[i] = desc[i];
            }
            contentsType = string(typeBytes);
            // contentsName is the suffix after ')'
            uint256 nameLen = desc.length - lastParenIndex;
            contentsName = new bytes(nameLen);
            for (uint256 i = 0; i < nameLen; i++) {
                contentsName[i] = desc[lastParenIndex + i];
            }
        }

        // Build TypedDataSign type encoding (uses contentsType, not full descriptor for explicit mode)
        string memory typeString = string(
            abi.encodePacked(
                "TypedDataSign(",
                contentsName,
                " contents,string name,uint256 chainId,address verifyingContract)",
                contentsType
            )
        );

        // Compute the TypedDataSign struct hash
        bytes32 typedDataSignStructHash = keccak256(
            abi.encode(keccak256(bytes(typeString)), contentsHash, NAMEHASH, block.chainid, proxy)
        );

        // The signing hash uses the app domain separator + TypedDataSign struct hash
        bytes32 signingHash = _hashEip712(appDomainSeparator, typedDataSignStructHash);

        // Sign with compact signature
        bytes memory sig = _signCompact(privateKey, signingHash);

        // Compute the hash that will be passed to isValidSignature
        signedHash = _hashEip712(appDomainSeparator, contentsHash);

        // Build the full signature: r || vs || appDomainSeparator || contentsHash || contentsDescriptor || length(2 bytes)
        signature = abi.encodePacked(
            sig, appDomainSeparator, contentsHash, bytes(contentsDescriptor), uint16(bytes(contentsDescriptor).length)
        );
    }

    /// @notice Build ERC7739 signature components (for tests that need individual r, vs values)
    /// @param privateKey Signer's private key
    /// @param proxy The proxy address (verifying contract)
    /// @param appDomainSeparator The application's domain separator
    /// @param contentsHash The contents struct hash
    /// @param contentsDescriptor The type descriptor string (compact or explicit mode)
    /// @return r ECDSA r component
    /// @return vs ECDSA compact vs component
    /// @return signedHash The hash passed to isValidSignature
    function _buildERC7739Components(
        uint256 privateKey,
        address proxy,
        bytes32 appDomainSeparator,
        bytes32 contentsHash,
        string memory contentsDescriptor
    ) internal view returns (bytes32 r, bytes32 vs, bytes32 signedHash) {
        bytes memory desc = bytes(contentsDescriptor);

        // Determine if compact mode (ends with ')') or explicit mode (ends with contentsName)
        bool isCompactMode = desc[desc.length - 1] == ")";

        // For explicit mode, find the rightmost ')' to split contentsType from contentsName
        string memory contentsType;
        bytes memory contentsName;

        if (isCompactMode) {
            // Compact mode: descriptor IS the contentsType
            contentsType = contentsDescriptor;
            // Extract contentsName from the beginning (up to first '(')
            uint256 parenIndex = 0;
            for (uint256 i = 0; i < desc.length; i++) {
                if (desc[i] == "(") {
                    parenIndex = i;
                    break;
                }
            }
            contentsName = new bytes(parenIndex);
            for (uint256 i = 0; i < parenIndex; i++) {
                contentsName[i] = desc[i];
            }
        } else {
            // Explicit mode: descriptor = contentsType + contentsName
            // Scan backward from end to find rightmost ')'
            uint256 lastParenIndex = desc.length;
            for (uint256 i = desc.length; i > 0; i--) {
                if (desc[i - 1] == ")") {
                    lastParenIndex = i; // Position after the ')'
                    break;
                }
            }
            // contentsType is everything up to and including the ')'
            bytes memory typeBytes = new bytes(lastParenIndex);
            for (uint256 i = 0; i < lastParenIndex; i++) {
                typeBytes[i] = desc[i];
            }
            contentsType = string(typeBytes);
            // contentsName is the suffix after ')'
            uint256 nameLen = desc.length - lastParenIndex;
            contentsName = new bytes(nameLen);
            for (uint256 i = 0; i < nameLen; i++) {
                contentsName[i] = desc[lastParenIndex + i];
            }
        }

        // Build TypedDataSign type encoding (uses contentsType, not full descriptor for explicit mode)
        string memory typeString = string(
            abi.encodePacked(
                "TypedDataSign(",
                contentsName,
                " contents,string name,uint256 chainId,address verifyingContract)",
                contentsType
            )
        );

        // Compute the TypedDataSign struct hash
        bytes32 typedDataSignStructHash = keccak256(
            abi.encode(keccak256(bytes(typeString)), contentsHash, NAMEHASH, block.chainid, proxy)
        );

        // The signing hash uses the app domain separator + TypedDataSign struct hash
        bytes32 signingHash = _hashEip712(appDomainSeparator, typedDataSignStructHash);

        // Sign
        (uint8 v, bytes32 r_, bytes32 s) = vm.sign(privateKey, signingHash);
        r = r_;
        // ERC-2098: vs = (v - 27) << 255 | s
        vs = bytes32((uint256(v) - 27) << 255) | s;

        // The hash passed to isValidSignature
        signedHash = _hashEip712(appDomainSeparator, contentsHash);
    }

    /// @notice Helper: Create a simple metaTx signature (simple mode, nonce >> 96 == 0)
    function _signMetaTxSimple(
        uint256 privateKey,
        address proxy,
        IMultiCall.Call[] memory calls,
        uint256 contextdepth,
        uint256 nonce,
        uint256 deadline
    ) internal view returns (bytes memory) {
        // In simple mode, the owner address is ORed into the nonce before hashing
        address owner = vm.addr(privateKey);
        uint256 nonceWithOwner = nonce | (uint256(uint160(owner)) << 96);

        bytes32 signingHash = _computeMetaTxSigningHash(proxy, calls, contextdepth, nonceWithOwner, deadline);
        return _signCompact(privateKey, signingHash);
    }

    /// @notice Helper: Create a Merkle mode metaTx signature (nonce >> 96 != 0)
    function _signMetaTxMerkle(
        uint256 privateKey,
        address proxy,
        IMultiCall.Call[] memory calls,
        uint256 contextdepth,
        uint256 nonce,
        uint256 deadline
    ) internal view returns (bytes memory signature, bytes32 signingHash) {
        signingHash = _computeMetaTxSigningHash(proxy, calls, contextdepth, nonce, deadline);
        // For Merkle mode, signature is abi.encode(proof) where proof proves signingHash is in the Merkle root
        // Since we're using single-leaf trees, proof is empty
        bytes32[] memory proof = new bytes32[](0);
        signature = abi.encode(proof);
    }

    /// @notice Helper to compute the _nonEip712SigningHash (sentinel domain path)
    /// @dev Replicates the contract's _nonEip712SigningHash function
    /// @param structHash The EIP-712 struct hash
    /// @return signingHash The hash using sentinel domain separator
    function _computeNonEip712SigningHash(bytes32 structHash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(hex"1901", SENTINEL_DOMAIN_SEPARATOR, structHash));
    }

    // =========================================================================
    // HELPER FUNCTIONS - Mock Contracts
    // =========================================================================

    /// @notice Deploy a simple mock ERC20 that always returns true for approve
    function _deployMockERC20() internal returns (address token) {
        // Use vm.etch + vm.mockCall for reliable mock behavior
        // Mock returns: balanceOf -> 1000 ether, approve -> true
        token = address(uint160(uint256(keccak256(abi.encodePacked("MockERC20", block.timestamp, gasleft())))));
        vm.etch(token, hex"00"); // Give it some code so it's a contract

        // Mock balanceOf to return 1000 ether for any address
        vm.mockCall(token, abi.encodeWithSelector(IERC20.balanceOf.selector), abi.encode(1000 ether));

        // Mock approve to return true
        vm.mockCall(token, abi.encodeWithSelector(IERC20.approve.selector), abi.encode(true));

        vm.label(token, "MockERC20");
    }

    /// @notice Deploy a mock ERC20 that returns false for approve
    function _deployMockERC20ReturnsFalse() internal returns (address token) {
        // ERC20 that returns false for approve
        bytes memory code = hex"608060405234801561001057600080fd5b506004361061004c5760003560e01c8063095ea7b31461005157806318160ddd1461008157806323b872dd1461009f57806370a08231146100cf575b600080fd5b61006b60048036038101906100669190610170565b6100ff565b60405161007891906101cb565b60405180910390f35b61008961010e565b60405161009691906101f5565b60405180910390f35b6100b960048036038101906100b49190610210565b61011e565b6040516100c691906101cb565b60405180910390f35b6100e960048036038101906100e49190610263565b61012e565b6040516100f691906101f5565b60405180910390f35b60006000905092915050565b6000683635c9adc5dea00000905090565b600060019050949350505050565b6000683635c9adc5dea00000905091905056";
        assembly {
            token := create(0, add(code, 0x20), mload(code))
        }
        vm.label(token, "MockERC20ReturnsFalse");
    }

    /// @notice Deploy a mock contract that can receive ETH and has arbitrary functions
    function _deployMockTarget() internal returns (address target) {
        // Deploy a proper Solidity contract that can receive ETH and echo values
        // This replaces the raw bytecode approach which had issues with return data
        target = address(new MockTarget());
        vm.label(target, "MockTarget");
    }

    /// @notice Calculate the total value from calls array
    function _sumCallValues(IMultiCall.Call[] memory calls) internal pure returns (uint256 total) {
        for (uint256 i = 0; i < calls.length; i++) {
            total += calls[i].value;
        }
    }

    /// @notice Verify selfdestruct was executed using state diff recording
    /// @dev Due to EIP-6780, selfdestruct only zeroes code at END of transaction.
    ///      Within the transaction, code.length is still > 0. This helper uses
    ///      vm.stopAndReturnStateDiff() to verify the SELFDESTRUCT opcode was executed.
    /// @param accesses The array of AccountAccess from vm.stopAndReturnStateDiff()
    /// @param expectedAccessor The address of the contract that should have selfdestructed
    /// @return found True if a non-reverted SelfDestruct was recorded from the expectedAccessor
    function _verifySelfDestructExecuted(
        VmSafe.AccountAccess[] memory accesses,
        address expectedAccessor
    ) internal pure returns (bool found) {
        for (uint256 i = 0; i < accesses.length; i++) {
            if (accesses[i].kind == VmSafe.AccountAccessKind.SelfDestruct) {
                // For SelfDestruct: accessor is the contract that selfdestructed
                if (accesses[i].accessor == expectedAccessor && !accesses[i].reverted) {
                    return true;
                }
            }
        }
        return false;
    }

    // =========================================================================
    // TESTS - Section 1: Constructor (CTOR-01 to CTOR-28)
    // Note: Many constructor tests are difficult/impossible to implement because
    // they require deploying the factory with specific conditions that can't be
    // simulated after the fact. The feasible tests are implemented below.
    // =========================================================================

    /// @notice CTOR-05: valid deployment (TOEHOLD sender, address < 2^104) passes
    function test_CTOR05_toeholdVanityAddress_deploysSuccessfully() public {
        address factoryAddr = address(0x00000000000000FfEeDd001122334455667799);

        vm.chainId(1);
        vm.setNonce(factoryAddr, 1);
        vm.deal(TOEHOLD, 2 wei);

        vm.startPrank(TOEHOLD);
        deployCodeTo("CrossChainReceiverFactory.sol", "", 2 wei, factoryAddr);
        vm.stopPrank();

        assertGt(factoryAddr.code.length, 0, "Factory should deploy at vanity address");
    }

    /// @notice CTOR-07: invalid (not TOEHOLD, chainid != 31337) reverts
    function test_CTOR07_notToehold_chainIdNot31337_reverts() public {
        vm.chainId(1);
        vm.expectRevert();
        new CrossChainReceiverFactory();
    }

    /// @notice CTOR-08: invalid (address >= 2^104, chainid != 31337) reverts
    function test_CTOR08_nonVanityAddress_chainIdNot31337_reverts() public {
        address factoryAddr = address(0x1111111111111111111111111111111111111111);

        vm.chainId(1);
        vm.setNonce(factoryAddr, 1);

        vm.startPrank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 0, factoryAddr);
        vm.stopPrank();
    }

    /// @notice CTOR-14: Constructor requires balance > 1 wei, reverts if insufficient
    /// @dev Tests that deploying with 0 or 1 wei causes the constructor to revert
    function test_CTOR14_insufficientBalance_reverts() public {
        address newFactoryAddr = address(uint160(uint256(keccak256("ctor14_factory"))));

        // Balance check should fail even with chainid bypass.
        vm.chainId(31337);
        vm.deal(TOEHOLD, 0);

        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 0, newFactoryAddr);
    }

    /// @notice CTOR-20: Refund to tx.origin succeeds during construction
    /// @dev After deployment, all constructor ETH should be refunded to tx.origin
    function test_CTOR20_refundToTxOrigin_succeeds() public {
        // Constructor refunds all ETH to tx.origin.
        assertEq(address(factory).balance, 0);
    }

    /// @notice CTOR-21: balanceOf(this) reverts during constructor - constructor reverts
    /// @dev Tests that if WETH.balanceOf() reverts, the factory constructor fails
    function test_CTOR21_balanceOfReverts_constructorReverts() public {
        // Save the original WETH bytecode so we can restore it for other tests
        bytes memory originalWethCode = address(WETH).code;

        // Deploy broken WETH that reverts on any call
        // Bytecode: PUSH1 0x00, PUSH1 0x00, REVERT (unconditionally reverts with no data)
        bytes memory brokenWethCode = hex"60006000fd";
        vm.etch(address(WETH), brokenWethCode);

        // Pick an unused address for the new factory
        address newFactoryAddr = address(uint160(uint256(keccak256("ctor21_factory"))));

        // Setup: chainid 31337 bypasses TOEHOLD/vanity requirements
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        // Attempt to deploy factory - should fail because WETH.balanceOf reverts
        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);

        // Restore original WETH code for subsequent tests
        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice CTOR-22: deposit{value}() doesn't increase balance - constructor reverts
    function test_CTOR22_depositDoesntIncreaseBalance_constructorReverts() public {
        bytes memory originalWethCode = address(WETH).code;

        // Mock WETH: balanceOf always returns 0, deposit succeeds silently
        bytes memory mockWethCode = hex"60003560e01c806370a0823114601f578063d0e30db014602a5760006000fd5b600060005260206000f35b00";
        vm.etch(address(WETH), mockWethCode);

        address newFactoryAddr = address(uint160(uint256(keccak256("ctor22_factory"))));
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);

        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice CTOR-23: fallback deposit call fails - constructor reverts
    function test_CTOR23_fallbackCallFails_constructorReverts() public {
        bytes memory originalWethCode = address(WETH).code;

        // Mock WETH: balanceOf returns storage[0] and increments by 1 ether, deposit works, fallback reverts
        bytes memory mockWethCode =
            hex"3615604a5760003560e01c806370a08231146024578063d0e30db014603f5760006000fd5b5060005480670de0b6b3a76400000160005560005260206000f35b506000543401600055005b60006000fd";
        vm.etch(address(WETH), mockWethCode);

        address newFactoryAddr = address(uint160(uint256(keccak256("ctor23_factory"))));
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);

        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice CTOR-24: fallback returns data (returndata.length != 0) - constructor reverts
    function test_CTOR24_fallbackReturnsData_constructorReverts() public {
        bytes memory originalWethCode = address(WETH).code;

        // Mock WETH: like CTOR-23 but fallback returns 32 bytes instead of reverting
        bytes memory mockWethCode =
            hex"3615604a5760003560e01c806370a08231146024578063d0e30db014603f5760006000fd5b5060005480670de0b6b3a76400000160005560005260206000f35b506000543401600055005b60206000f3";
        vm.etch(address(WETH), mockWethCode);

        address newFactoryAddr = address(uint160(uint256(keccak256("ctor24_factory"))));
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);

        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice CTOR-25: fallback doesn't increase balance - constructor reverts
    function test_CTOR25_fallbackNoBalanceIncrease_constructorReverts() public {
        bytes memory originalWethCode = address(WETH).code;

        // Mock WETH: counter-based balanceOf returns same value after fallback (no increase)
        bytes memory mockWethCode =
            hex"3615605c5760003560e01c806370a08231146024578063d0e30db01460595760006000fd5b506000548060021015603857806001016000555b15604e57670de0b6b3a764000060005260206000f35b600060005260206000f35b50005b00";
        vm.etch(address(WETH), mockWethCode);

        address newFactoryAddr = address(uint160(uint256(keccak256("ctor25_factory"))));
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);

        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice CTOR-26: withdraw doesn't return correct ETH - constructor reverts
    function test_CTOR26_withdrawIncorrectEth_constructorReverts() public {
        bytes memory originalWethCode = address(WETH).code;

        // Mock WETH: withdraw() clears balance but doesn't send ETH back
        bytes memory mockWethCode =
            hex"3615604e5760003560e01c806370a0823114602e578063d0e30db014603b578063"
            hex"2e1a7d4d14604657600060"
            hex"00fd5b5060005460005260206000f35b506000543401600055005b506000600055005b600054340160005500";
        vm.etch(address(WETH), mockWethCode);

        address newFactoryAddr = address(uint160(uint256(keccak256("ctor26_factory"))));
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);

        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice CTOR-27: WETH balance not zero after withdraw - constructor reverts
    function test_CTOR27_balanceNotZeroAfterWithdraw_constructorReverts() public {
        bytes memory originalWethCode = address(WETH).code;

        // Mock WETH: balanceOf returns 1 after withdraw instead of 0
        bytes memory mockWethCode =
            hex"36156073576000"
            hex"3560e01c806370"
            hex"a0823114602e57"
            hex"8063d0e30db014"
            hex"604d5780632e1a"
            hex"7d4d1460585760"
            hex"006000fd5b5060"
            hex"0154156041576001"
            hex"60005260206000"
            hex"f35b6000546000"
            hex"5260206000f35b"
            hex"5060005434016000"
            hex"55005b50600160"
            hex"01556004356000"
            hex"6000556000806000"
            hex"808433"
            hex"5af150005b6000"
            hex"5434016000"
            hex"5500";
        vm.etch(address(WETH), mockWethCode);

        address newFactoryAddr = address(uint160(uint256(keccak256("ctor27_factory"))));
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        vm.prank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);

        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice CTOR-28: refund to tx.origin fails - constructor reverts
    function test_CTOR28_refundToTxOriginFails_constructorReverts() public {
        // Contract that rejects ETH transfers
        address rejectingOrigin = address(uint160(uint256(keccak256("rejecting_origin"))));
        vm.etch(rejectingOrigin, hex"60006000fd");

        address newFactoryAddr = address(uint160(uint256(keccak256("ctor28_factory"))));
        vm.chainId(31337);
        vm.deal(TOEHOLD, 10 wei);

        // Set tx.origin to rejectingOrigin so the constructor's refund call fails
        vm.prank(TOEHOLD, rejectingOrigin);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 5 wei, newFactoryAddr);
    }



    /// @notice CTOR-31: _WNATIVE != address(0) resolves to WETH
    function test_CTOR31_wnativeNonZero_storageResolvesToWeth() public view {
        address resolved = address(uint160(uint256(bytes32(wnativeStorage.code))));
        assertEq(resolved, address(WETH));
        assertTrue(resolved != address(0));
    }



    // Receive function needed for withdraw tests
    receive() external payable {}

    /// @notice CTOR-37: CONTINUE policy + non-OOG revert returns empty failure result
    function test_CTOR37_continuePolicy_nonOogRevert_swallowed() public {
        address revertTarget;
        assembly ("memory-safe") {
            mstore(0x00, 0x623d3dfd3d526003601df3)
            revertTarget := create(0x00, 0x15, 0x0b)
        }
        require(revertTarget != address(0), "revert target deploy failed");

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = revertTarget;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.CONTINUE;

        vm.prank(address(factory));
        IMultiCall.Result[] memory results =
            IMultiCall(payable(EIP150_MULTICALL_ADDRESS)).multicall{gas: 100_000}(calls, 1);

        assertEq(results.length, 1);
        assertFalse(results[0].success);
        assertEq(results[0].data.length, 0);
    }

    /// @notice CTOR-38: identity precompile echo returns data + appended sender
    function test_CTOR38_identityPrecompile_echoesDataWithSender() public {
        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = address(4); // identity precompile
        calls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        calls[0].data = "Hello, World!";

        vm.prank(address(factory));
        IMultiCall.Result[] memory results = IMultiCall(payable(EIP150_MULTICALL_ADDRESS)).multicall(calls, 1);

        assertEq(results.length, 1);
        assertTrue(results[0].success);
        bytes memory expected = bytes.concat("Hello, World!", bytes20(uint160(address(factory))));
        assertEq(keccak256(results[0].data), keccak256(expected));
    }

    // =========================================================================
    // TESTS - Section 2: Modifiers (MOD-01 to MOD-11)
    // =========================================================================

    /// @notice MOD-01: onlyProxy - called on factory reverts
    function test_MOD01_onlyProxy_calledOnFactory_reverts() public {
        vm.expectRevert();
        factory.isValidSignature(bytes32(0), "");
    }


    /// @notice MOD-04: noDelegateCall - delegatecall context reverts
    function test_MOD04_noDelegateCall_delegateCallReverts() public {
        // Delegatecall should fail the noDelegateCall check.
        DelegateCallAttacker attacker = new DelegateCallAttacker(address(factory));

        vm.expectRevert();
        attacker.tryDelegateCallDeploy(bytes32(uint256(123)), true, defaultOwner);
    }

    /// @notice MOD-06: onlyFactory - msg.sender is not factory reverts
    function test_MOD06_onlyFactory_msgSenderNotFactory_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("action"));
        vm.expectRevert();
        proxy.setOwner(address(0x1234));
    }

    // =========================================================================
    // TESTS - Section 3: deploy() (DEP-01 to DEP-14)
    // =========================================================================

    /// @notice DEP-01: Deterministic salt from (root, owner)
    function test_DEP01_deterministicSalt_sameInputs_sameAddress() public {
        bytes32 root = keccak256("test_root");
        address owner1 = address(0x1111);

        ICrossChainReceiverFactory proxy1 = factory.deploy(root, true, owner1);

        bytes32 salt = keccak256(abi.encodePacked(root, owner1));
        bytes32 initCodeHash = keccak256(
            abi.encodePacked(
                hex"60253d8160093d39f33d3d3d3d363d3d37363d6c",
                bytes13(uint104(uint160(address(factory)))),
                hex"5af43d3d93803e602357fd5bf3"
            )
        );
        address expected =
            address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(factory), salt, initCodeHash)))));

        assertEq(address(proxy1), expected);
    }

    /// @notice DEP-05: Deployment to same salt twice reverts with DeploymentFailed
    function test_DEP05_sameSaltTwice_reverts() public {
        bytes32 root = keccak256("duplicate_test");
        factory.deploy(root, true, defaultOwner);

        vm.expectRevert(abi.encodeWithSignature("DeploymentFailed()"));
        factory.deploy(root, true, defaultOwner);
    }

    /// @notice DEP-06: Proxy bytecode matches expected EIP-1167 minimal proxy
    function test_DEP06_proxyBytecode_matchesExpected() public {
        ICrossChainReceiverFactory proxy = factory.deploy(keccak256("bytecode_test"), true, defaultOwner);

        bytes memory expected = abi.encodePacked(
            hex"3d3d3d3d363d3d37363d6c", uint104(uint160(address(factory))), hex"5af43d3d93803e602357fd5bf3"
        );

        assertEq(address(proxy).code, expected);
    }

    /// @notice DEP-07: setOwnerNotCleanup=true calls setOwner(initialOwner)
    function test_DEP07_setOwnerNotCleanup_true_setsOwner() public {
        address expectedOwner = address(0x5678);
        ICrossChainReceiverFactory proxy = factory.deploy(keccak256("set_owner_test"), true, expectedOwner);

        assertEq(proxy.owner(), expectedOwner);
    }

    /// @notice DEP-08: setOwnerNotCleanup=false calls cleanup(proxy)
    function test_DEP08_setOwnerNotCleanup_false_callsCleanup() public {
        // When cleanup is called during deploy, the proxy gets selfdestructed
        // Post-Cancun, selfdestruct in same tx as creation destroys the contract
        // Note: EIP-6780 specifies destruction happens at END of tx, so we use
        // state diff recording to verify SELFDESTRUCT opcode was executed
        vm.startStateDiffRecording();
        ICrossChainReceiverFactory proxy = factory.deploy(keccak256("cleanup_test"), false, defaultOwner);
        VmSafe.AccountAccess[] memory accesses = vm.stopAndReturnStateDiff();

        // Verify selfdestruct was executed on the proxy
        assertTrue(
            _verifySelfDestructExecuted(accesses, address(proxy)),
            "Proxy should have executed selfdestruct"
        );
    }

    /// @notice DEP-09: initialOwner=address(0) with setOwnerNotCleanup=true sets owner to 0
    function test_DEP09_zeroOwner_setOwner_setsToZero() public {
        ICrossChainReceiverFactory proxy = factory.deploy(keccak256("zero_owner_test"), true, address(0));

        assertEq(proxy.owner(), address(0));
    }

    // =========================================================================
    // TESTS - Section 5: approvePermit2() (APR-01 to APR-13)
    // =========================================================================

    /// @notice APR-01: token == NATIVE_ADDRESS wraps ETH then approves WETH
    function test_APR01_nativeToken_wrapsAndApproves() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("apr01"), defaultOwnerKey, false);
        vm.deal(address(proxy), 1 ether);

        proxy.approvePermit2(NATIVE, 0.5 ether);

        assertEq(address(proxy).balance, 0.5 ether);
        assertEq(WETH.balanceOf(address(proxy)), 0.5 ether);
        assertEq(WETH.allowance(address(proxy), PERMIT2), 0.5 ether);
    }

    /// @notice APR-02: token == regular ERC20 approves token directly
    function test_APR02_regularERC20_approvesDirectly() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("apr02"), defaultOwnerKey, false);

        proxy.approvePermit2(WETH, 1 ether);

        assertEq(WETH.allowance(address(proxy), PERMIT2), 1 ether);
    }

    /// @notice APR-04: proxy has insufficient ETH reverts
    function test_APR04_insufficientETH_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("apr04"), defaultOwnerKey, false);
        vm.deal(address(proxy), 0.5 ether);

        vm.expectRevert();
        proxy.approvePermit2(NATIVE, 1 ether);
    }

    /// @notice APR-07: approve returns empty (USDT-style) - success
    function test_APR07_approveReturnsEmpty_succeeds() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("apr07"), defaultOwnerKey, false);

        address mockToken = address(0x7777777777777777777777777777777777777777);
        vm.etch(mockToken, hex"00"); // Give it some code so it's not an EOA

        vm.mockCall(mockToken, abi.encodeWithSelector(IERC20.approve.selector), "");

        bool result = proxy.approvePermit2(IERC20(mockToken), 1 ether);
        assertTrue(result);
    }

    /// @notice APR-08: approve returns false - reverts with ApproveFailed
    function test_APR08_approveReturnsFalse_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("apr08"), defaultOwnerKey, false);

        address mockToken = address(0x9999999999999999999999999999999999999999);
        vm.etch(mockToken, hex"00"); // Give it some code so it's not an EOA

        vm.mockCall(mockToken, abi.encodeWithSelector(IERC20.approve.selector), abi.encode(false));

        vm.expectRevert(abi.encodeWithSelector(bytes4(0x3e3f8f73))); // ApproveFailed
        proxy.approvePermit2(IERC20(mockToken), 1 ether);
    }

    /// @notice APR-09: approve reverts - bubbles revert
    function test_APR09_approveReverts_bubbles() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("apr09"), defaultOwnerKey, false);

        address mockToken = address(0x8888888888888888888888888888888888888888);
        vm.etch(mockToken, hex"00"); // Give it some code

        // Mock approve to revert
        vm.mockCallRevert(mockToken, abi.encodeWithSelector(IERC20.approve.selector), "APPROVAL_FAILED");

        vm.expectRevert("APPROVAL_FAILED");
        proxy.approvePermit2(IERC20(mockToken), 1 ether);
    }

    // =========================================================================
    // CAL: call() simple
    // =========================================================================

    /// @notice CAL-01: call contract with data executes and returns result
    function test_CAL01_callWithData_executesAndReturns() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("cal01"));

        vm.prank(owner);
        bytes memory result =
            proxy.call(payable(address(WETH)), 0, abi.encodeWithSelector(IERC20.balanceOf.selector, address(proxy)));

        assertEq(abi.decode(result, (uint256)), 0);
    }

    /// @notice CAL-02: call contract with value transfers ETH
    function test_CAL02_callWithValue_transfersETH() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("cal02"));
        vm.deal(address(proxy), 1 ether);

        vm.prank(owner);
        bytes memory result = proxy.call(payable(address(WETH)), 0.5 ether, abi.encodeWithSignature("deposit()"));

        assertEq(result.length, 0, "Call should return empty data");
        assertEq(address(proxy).balance, 0.5 ether);
        assertEq(WETH.balanceOf(address(proxy)), 0.5 ether);
    }

    /// @notice CAL-03: call fails - reverts with target's error
    function test_CAL03_callFails_revertsWithTargetError() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("cal03"));

        vm.prank(owner);
        vm.expectRevert();
        proxy.call(payable(address(WETH)), 0, abi.encodeWithSelector(IERC20.transfer.selector, address(0x1234), 1 ether));
    }

    /// @notice CAL-04: data to EOA reverts
    function test_CAL04_dataToEOA_reverts() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("cal04"));

        vm.prank(owner);
        vm.expectRevert();
        proxy.call(payable(address(0xdead)), 0, hex"1234");
    }

    /// @notice CAL-06: pure ETH transfer to EOA (no data, value > 0) succeeds
    function test_CAL06_pureETHToEOA_succeeds() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("cal06"));
        vm.deal(address(proxy), 1 ether);

        address payable eoa = payable(address(0xdead));
        uint256 eoaBalanceBefore = eoa.balance;

        vm.prank(owner);
        proxy.call(eoa, 0.5 ether, "");

        assertEq(eoa.balance, eoaBalanceBefore + 0.5 ether);
    }

    // =========================================================================
    // PAT: call() patching
    // =========================================================================

    /// @notice PAT-01: patchOffset + 32 <= data.length succeeds
    function test_PAT01_validPatchOffset_succeeds() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat01"));

        bytes memory data = abi.encodeWithSignature("deposit()");
        bytes memory extendedData = new bytes(32);
        for (uint256 i = 0; i < data.length; i++) {
            extendedData[i] = data[i];
        }

        vm.prank(owner);
        proxy.call{value: 0}(payable(address(WETH)), WETH, 0, 0, extendedData);
    }

    /// @notice PAT-02: patchOffset + 32 > data.length reverts with Panic(0x32)
    function test_PAT02_invalidPatchOffset_reverts() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat02"));

        bytes memory data = hex"12345678";

        vm.prank(owner);
        vm.expectRevert(abi.encodeWithSignature("Panic(uint256)", 0x32));
        proxy.call{value: 0}(payable(address(WETH)), WETH, 0, 0, data);
    }

    /// @notice PAT-11: ppm == 0 results in patchBytes == 0
    function test_PAT11_ppmZero_patchBytesZero() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat11"));

        address mockTarget = _deployMockTarget();
        uint256 targetBalanceBefore = mockTarget.balance;

        bytes memory data = abi.encodeWithSignature("echo(uint256)", uint256(999));

        vm.prank(owner);
        proxy.call{value: 0}(payable(mockTarget), NATIVE, 0, 4, data);

        assertEq(mockTarget.balance, targetBalanceBefore, "No ETH should be sent with ppm=0");
    }

    /// @notice PAT-17: data to EOA reverts
    function test_PAT17_dataToEOA_reverts() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat17"));

        bytes memory data = new bytes(32);
        data[0] = 0x12;

        vm.prank(owner);
        vm.expectRevert();
        proxy.call{value: 0}(payable(address(0xdead)), NATIVE, 500000, 0, data);
    }

    /// @notice PAT-22: native token + empty data + patchOffset=0 succeeds (pure ETH send)
    function test_PAT22_nativeToken_emptyData_patchOffsetZero_succeeds() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat22"));
        vm.deal(address(proxy), 1 ether);

        address mockTarget = _deployMockTarget();
        uint256 targetBalanceBefore = mockTarget.balance;

        vm.prank(owner);
        proxy.call(payable(mockTarget), NATIVE, 500000, 0, "");

        assertEq(mockTarget.balance - targetBalanceBefore, 0.5 ether, "Target should receive patched ETH");
        assertEq(address(proxy).balance, 0.5 ether, "Proxy balance should decrease by patchBytes");
    }

    /// @notice PAT-23: ERC20 token + empty data + patchOffset=0 reverts with Panic(0x32)
    function test_PAT23_erc20_emptyData_reverts() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat23"));

        address token = _deployMockERC20();

        vm.prank(owner);
        vm.expectRevert(abi.encodeWithSignature("Panic(uint256)", 0x32));
        proxy.call(payable(address(WETH)), IERC20(token), 0, 0, "");
    }

    /// @notice PAT-24: native token + empty data + patchOffset>0 reverts with Panic(0x32)
    function test_PAT24_nativeToken_emptyData_patchOffsetNonZero_reverts() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat24"));

        vm.prank(owner);
        vm.expectRevert(abi.encodeWithSignature("Panic(uint256)", 0x32));
        proxy.call(payable(address(WETH)), NATIVE, 0, 1, "");
    }

    // =========================================================================
    // CLN: cleanup
    // =========================================================================

    /// @notice CLN-01: factory calls, proxy has ETH - wraps to WETH, then selfdestructs
    function test_CLN01_factoryPath_hasETH_wrapsAndDestructs() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("cln01"), defaultOwnerKey, true);
        vm.deal(address(proxy), 1 ether);

        bytes32 root = _hashLeaf(keccak256("cln01_cleanup"));
        address owner = vm.addr(defaultOwnerKey);

        // Use state diff to detect SELFDESTRUCT (EIP-6780).
        vm.startStateDiffRecording();
        ICrossChainReceiverFactory newProxy = factory.deploy(root, false, owner);
        VmSafe.AccountAccess[] memory accesses = vm.stopAndReturnStateDiff();

        assertTrue(
            _verifySelfDestructExecuted(accesses, address(newProxy)),
            "Proxy should have executed selfdestruct"
        );
    }

    /// @notice CLN-02: factory calls, proxy has no ETH - skips wrap
    function test_CLN02_factoryPath_noETH_skipsWrap() public {
        bytes32 root = _hashLeaf(keccak256("cln02"));

        // Use state diff to detect SELFDESTRUCT (EIP-6780).
        vm.startStateDiffRecording();
        ICrossChainReceiverFactory proxy = factory.deploy(root, false, defaultOwner);
        VmSafe.AccountAccess[] memory accesses = vm.stopAndReturnStateDiff();

        assertTrue(
            _verifySelfDestructExecuted(accesses, address(proxy)),
            "Proxy should have executed selfdestruct"
        );
    }

    /// @notice CLN-04: owner calls - selfdestructs to beneficiary
    function test_CLN04_ownerPath_selfdestructs() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("cln04"));
        vm.deal(address(proxy), 1 ether);

        address beneficiary = address(0x1234);
        uint256 beneficiaryBalanceBefore = beneficiary.balance;

        vm.prank(owner);
        proxy.cleanup(payable(beneficiary));

        assertEq(beneficiary.balance, beneficiaryBalanceBefore + 1 ether);
    }

    /// @notice CLN-06: non-owner, non-self calls - reverts with PermissionDenied
    function test_CLN06_nonOwner_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("cln06"));

        address nonOwner = address(0xbeef);
        vm.prank(nonOwner);
        vm.expectRevert(IOwnable.PermissionDenied.selector);
        proxy.cleanup(payable(nonOwner));
    }


    // =========================================================================
    // SIG: isValidSignature
    // =========================================================================

    /// @notice SIG-01: signature.length == 0 && hash == magic returns 0x77390001
    function test_SIG01_emptySignature_magicHash_returns77390001() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("sig01"));

        bytes4 result = proxy.isValidSignature(ERC7739_MAGIC_HASH, "");

        assertEq(result, bytes4(0x77390001));
    }

    /// @notice SIG-02: signature.length == 0 && hash != magic returns 0xffffffff
    function test_SIG02_emptySignature_nonMagicHash_returnsInvalid() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("sig02"));

        bytes4 result = proxy.isValidSignature(bytes32(uint256(1)), "");

        assertEq(result, INVALID_SIG);
    }

    /// @notice SIG-09: invalid ECDSA signature (wrong signer) returns 0xffffffff
    function test_SIG09_invalidECDSA_wrongSigner_returnsInvalid() public {
        uint256 ownerKey = uint256(keccak256("sig09_owner"));
        uint256 wrongKey = uint256(keccak256("sig09_wrong"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("sig09_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("TestData(uint256 value)"), uint256(12345)));
        string memory contentsDescriptor = "TestData(uint256 value)";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(wrongKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes4 result = proxy.isValidSignature(signedHash, signature);

        assertEq(result, INVALID_SIG);
    }

    // =========================================================================
    // RCV: receive
    // =========================================================================

    /// @notice RCV-02: ETH from any other address wraps to WETH
    function test_RCV02_ethFromOtherAddress_wrapsToWETH() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("rcv02"), defaultOwnerKey, false);

        vm.deal(address(this), 1 ether);

        uint256 wethBalanceBefore = WETH.balanceOf(address(proxy));

        (bool success,) = address(proxy).call{value: 0.5 ether}("");
        assertTrue(success);

        assertEq(WETH.balanceOf(address(proxy)), wethBalanceBefore + 0.5 ether);
        assertEq(address(proxy).balance, 0);
    }

    /// @notice RCV-09: _MISSING_WNATIVE=false, sender == _WNATIVE accepts silently
    function test_RCV09_hasWnative_senderIsWeth_acceptsSilently() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("rcv09"), defaultOwnerKey, false);

        uint256 sendAmount = 0.25 ether;
        vm.deal(address(WETH), sendAmount);

        uint256 wethBalanceBefore = WETH.balanceOf(address(proxy));
        uint256 ethBalanceBefore = address(proxy).balance;

        vm.prank(address(WETH));
        (bool success,) = address(proxy).call{value: sendAmount}("");
        assertTrue(success);
        assertEq(WETH.balanceOf(address(proxy)), wethBalanceBefore, "WETH sender should not trigger wrap");
        assertEq(address(proxy).balance, ethBalanceBefore + sendAmount);
    }

    // =========================================================================
    // OWN: ownership
    // =========================================================================

    /// @notice OWN-07: transferOwnership by owner to address(0) reverts with ZeroAddress
    function test_OWN07_transferOwnership_toZero_reverts() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("own07"));

        vm.prank(owner);
        vm.expectRevert(IOwnable.ZeroAddress.selector);
        proxy.transferOwnership(address(0));
    }

    /// @notice OWN-08: transferOwnership by non-owner reverts with PermissionDenied
    function test_OWN08_transferOwnership_byNonOwner_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("own08"));

        address nonOwner = address(0xbeef);
        vm.prank(nonOwner);
        vm.expectRevert(IOwnable.PermissionDenied.selector);
        proxy.transferOwnership(address(0x1234));
    }

    /// @notice OWN-10: acceptOwnership by pendingOwner becomes owner
    function test_OWN10_acceptOwnership_byPending_becomesOwner() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("own10"));
        ITwoStepOwnable twoStep = ITwoStepOwnable(address(proxy));

        address newOwner = address(0x5678);
        vm.prank(owner);
        proxy.transferOwnership(newOwner);

        vm.prank(newOwner);
        twoStep.acceptOwnership();

        assertEq(proxy.owner(), newOwner);
        assertEq(twoStep.pendingOwner(), address(0));
    }

    /// @notice OWN-12: acceptOwnership when no pending owner reverts
    function test_OWN12_acceptOwnership_noPending_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("own12"));
        ITwoStepOwnable twoStep = ITwoStepOwnable(address(proxy));

        vm.prank(address(0x1234));
        vm.expectRevert(IOwnable.PermissionDenied.selector);
        twoStep.acceptOwnership();
    }

    /// @notice OWN-14: rejectOwnership by pendingOwner clears pending
    function test_OWN14_rejectOwnership_byPending_clearsPending() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("own14"));
        ITwoStepOwnable twoStep = ITwoStepOwnable(address(proxy));

        address newOwner = address(0x5678);
        vm.prank(owner);
        proxy.transferOwnership(newOwner);

        vm.prank(newOwner);
        twoStep.rejectOwnership();

        assertEq(twoStep.pendingOwner(), address(0));
        assertEq(proxy.owner(), owner);
    }

    /// @notice OWN-15: rejectOwnership by non-pendingOwner reverts
    function test_OWN15_rejectOwnership_byNonPending_reverts() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("own15"));
        ITwoStepOwnable twoStep = ITwoStepOwnable(address(proxy));

        address newOwner = address(0x5678);
        vm.prank(owner);
        proxy.transferOwnership(newOwner);

        address random = address(0xbeef);
        vm.prank(random);
        vm.expectRevert(IOwnable.PermissionDenied.selector);
        twoStep.rejectOwnership();
    }

    /// @notice OWN-18: renounceOwnership with pending owner clears pending then sets owner to 0
    function test_OWN18_renounceOwnership_clearsPendingFirst() public {
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("own18"));
        ITwoStepOwnable twoStep = ITwoStepOwnable(address(proxy));

        address pending = address(0x5678);
        vm.prank(owner);
        proxy.transferOwnership(pending);

        vm.prank(owner);
        twoStep.renounceOwnership();

        assertEq(proxy.owner(), address(0));
        assertEq(twoStep.pendingOwner(), address(0));
    }

    // =========================================================================
    // IFC: supportsInterface
    // =========================================================================

    /// @notice IFC-01: IERC165.interfaceId (0x01ffc9a7) returns true
    function test_IFC01_supportsIERC165() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("ifc01"));
        assertTrue(proxy.supportsInterface(type(IERC165).interfaceId));
    }

    /// @notice IFC-02: IOwnable.interfaceId (0x7f5828d0) returns true
    function test_IFC02_supportsIOwnable() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("ifc02"));
        assertTrue(proxy.supportsInterface(type(IOwnable).interfaceId));
    }

    /// @notice IFC-03: any other interfaceId returns false
    function test_IFC03_otherInterface_returnsFalse() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("ifc03"));
        assertFalse(proxy.supportsInterface(bytes4(0x12345678)));
    }

    // =========================================================================
    // DOM: eip712Domain
    // =========================================================================

    /// @notice DOM-02: returns name = "ZeroExCrossChainReceiver"
    function test_DOM02_nameIsCorrect() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("dom02"));

        (bytes1 fields, string memory name_,, uint256 chainId, address verifyingContract,,) = proxy.eip712Domain();

        assertEq(fields, bytes1(0x0d));
        assertEq(keccak256(bytes(name_)), NAMEHASH);
        assertEq(chainId, block.chainid);
        assertEq(verifyingContract, address(proxy));
    }

    // =========================================================================
    // TESTS - Section: metaTx() (MTX-01 to MTX-33)
    // =========================================================================

    /// @notice MTX-02: deadline expired - reverts with SignatureExpired
    function test_MTX02_deadlineExpired_reverts() public {
        uint256 ownerKey = uint256(keccak256("mtx02"));

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp - 1;

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        vm.expectRevert(abi.encodeWithSelector(bytes4(0xcd21db4f), deadline));
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
    }

    /// @notice MTX-04: relayer specified, wrong sender - reverts with PermissionDenied
    function test_MTX04_relayerSpecified_wrongSender_reverts() public {
        uint256 ownerKey = uint256(keccak256("mtx04"));
        address relayer = address(0xBEEF);
        address wrongSender = address(0xDEAD);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = (uint256(uint160(relayer)) << 96) | (block.timestamp + 1000);

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        vm.prank(wrongSender);
        vm.expectRevert();
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
    }

    /// @notice MTX-16: already-used nonce - reverts with InvalidNonce
    function test_MTX16_usedNonce_reverts() public {
        uint256 ownerKey = uint256(keccak256("mtx16"));

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        bytes memory signature1 = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        proxy.metaTx(calls, contextdepth, nonce, deadline, signature1);

        vm.expectRevert();
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature1);
    }

    /// @notice MTX-19: value forwarded correctly - ETH sent to multicall
    function test_MTX19_valueForwarded_correctly() public {
        uint256 ownerKey = uint256(keccak256("mtx19"));
        address target = address(0xCAFE);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = target;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.CONTINUE;
        calls[0].value = 1 ether;
        calls[0].data = "";

        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        vm.deal(address(proxy), 2 ether);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        uint256 targetBalanceBefore = target.balance;
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
        uint256 targetBalanceAfter = target.balance;

        assertEq(targetBalanceAfter - targetBalanceBefore, 1 ether);
    }

    /// @notice MTX-25: deadline = block.timestamp exactly - succeeds
    function test_MTX25_deadlineExactlyBlockTimestamp_succeeds() public {
        uint256 ownerKey = uint256(keccak256("mtx25"));

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp;

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        IMultiCall.Result[] memory results = proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
        assertEq(results.length, 0);
    }

    /// @notice MTX-27: selfbalance() >= value - no WETH unwrap needed
    function test_MTX27_sufficientETH_noUnwrapNeeded() public {
        uint256 ownerKey = uint256(keccak256("mtx27"));
        address target = address(0xCAFE);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = target;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.CONTINUE;
        calls[0].value = 1 ether;
        calls[0].data = "";

        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        vm.deal(address(proxy), 2 ether);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        uint256 wethBefore = WETH.balanceOf(address(proxy));
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
        uint256 wethAfter = WETH.balanceOf(address(proxy));

        assertEq(wethBefore, wethAfter);
    }

    /// @notice MTX-28: selfbalance() < value, WETH balance sufficient - unwraps exact shortfall
    function test_MTX28_insufficientETH_WETHSufficient_unwrapsShortfall() public {
        uint256 ownerKey = uint256(keccak256("mtx28"));
        address target = address(0xCAFE);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = target;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.CONTINUE;
        calls[0].value = 1 ether;
        calls[0].data = "";

        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        vm.deal(address(proxy), 0.3 ether);
        vm.deal(address(this), 1 ether);
        (bool success,) = address(WETH).call{value: 1 ether}(abi.encodeWithSignature("deposit()"));
        require(success, "WETH deposit failed");
        WETH.transfer(address(proxy), 1 ether);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        uint256 wethBefore = WETH.balanceOf(address(proxy));
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
        uint256 wethAfter = WETH.balanceOf(address(proxy));

        assertEq(wethBefore - wethAfter, 0.7 ether);
    }

    /// @notice MTX-31: multicall returns excess value - recovery call retrieves leftover ETH
    /// @dev Uses CONTINUE policy with a reverting contract to leave value in MultiCall.
    function test_MTX31_excessValueRecovered() public {
        uint256 ownerKey = uint256(keccak256("mtx31_owner"));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256("mtx31_root"), ownerKey);

        address revertingTarget = address(0xDEAD1234);
        vm.etch(revertingTarget, hex"60006000fd");

        uint256 excessAmount = 0.5 ether;
        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0] = IMultiCall.Call({
            target: revertingTarget,
            revertPolicy: IMultiCall.RevertPolicy.CONTINUE,
            value: excessAmount,
            data: hex"12345678"
        });

        uint256 contextdepth = 0;
        uint256 nonce = 31;
        uint256 deadline = block.timestamp + 1000;

        vm.deal(address(proxy), 1 ether);

        uint256 proxyWethBefore = WETH.balanceOf(address(proxy));

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        vm.prank(owner);
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);

        assertEq(address(EIP150_MULTICALL_ADDRESS).balance, 0, "MultiCall should have 0 balance after recovery");
        uint256 proxyWethAfter = WETH.balanceOf(address(proxy));
        assertEq(proxyWethAfter - proxyWethBefore, excessAmount, "Proxy WETH should increase by exact excess amount");
    }

    /// @notice MTX-33: recovery call fails - reverts
    function test_MTX33_recoveryCallFails_reverts() public {
        uint256 ownerKey = uint256(keccak256("mtx33_owner"));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256("mtx33_root"), ownerKey);

        bytes memory originalWethCode = address(WETH).code;

        bytes memory brokenWethCode = hex"60006000fd";
        vm.etch(address(WETH), brokenWethCode);

        address eoa = address(0xDEAD);
        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0] =
            IMultiCall.Call({target: eoa, revertPolicy: IMultiCall.RevertPolicy.CONTINUE, value: 0.5 ether, data: hex"12345678"});

        uint256 contextdepth = 0;
        uint256 nonce = 333;
        uint256 deadline = block.timestamp + 1000;

        vm.deal(address(proxy), 1 ether);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        vm.expectRevert();
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);

        vm.etch(address(WETH), originalWethCode);
    }

    // =========================================================================
    // TESTS - Section: Integration Tests (INT-01 to INT-28)
    // =========================================================================

    /// @notice INT-16: metaTx signature replay on different chain - fails
    function test_INT16_metaTxReplayDifferentChain_fails() public {
        uint256 ownerKey = uint256(keccak256("int16"));

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        (ICrossChainReceiverFactory proxy,) = _deployProxy(bytes32(uint256(1)), ownerKey);

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        vm.chainId(999);

        vm.expectRevert();
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
    }

    /// @notice INT-25: pre-fund CREATE2 address, deploy, access funds
    function test_INT25_preFundedAddress_fundsAccessible() public {
        bytes32 root = keccak256("int25_root");

        // Salt derivation: salt = keccak256(abi.encodePacked(root, initialOwner))
        bytes32 salt = keccak256(abi.encodePacked(root, defaultOwner));

        // Initcode: hex"60253d8160093d39f33d3d3d3d363d3d37363d6c" ++ bytes13(uint104(factory)) ++ hex"5af43d3d93803e602357fd5bf3"
        bytes memory initcode = abi.encodePacked(
            hex"60253d8160093d39f33d3d3d3d363d3d37363d6c",
            bytes13(uint104(uint160(address(factory)))),
            hex"5af43d3d93803e602357fd5bf3"
        );
        bytes32 initcodeHash = keccak256(initcode);

        // CREATE2 address = keccak256(0xff ++ factory ++ salt ++ keccak256(initcode))[12:]
        address predicted = address(
            uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(factory), salt, initcodeHash))))
        );

        vm.deal(predicted, 1 ether);
        assertEq(predicted.balance, 1 ether);

        ICrossChainReceiverFactory proxy = factory.deploy(root, true, defaultOwner);

        // Verify the prediction was correct
        assertEq(address(proxy), predicted, "Predicted address should match deployed address");

        // Proxy should have the funds (either as ETH or auto-wrapped to WETH since receive() wraps)
        // Pre-funded ETH is available at the address after deployment
        assertTrue(address(proxy).balance > 0 || WETH.balanceOf(address(proxy)) > 0);
    }

    // =========================================================================
    // TESTS - Section 13: _verifyDeploymentRootHash() (VDR-01 to VDR-03)
    // =========================================================================

    /// @notice VDR-01: correct root + owner for this proxy returns true
    function test_VDR01_correctRootAndOwner_returnsTrue() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("vdr_owner")));
        address owner = vm.addr(ownerKey);

        // Test via isValidSignature with Merkle proof (which calls _verifyDeploymentRootHash)
        bytes32 signingHash = keccak256(abi.encode("test_signing_hash"));
        bytes32 leaf = _hashLeaf(signingHash);
        (ICrossChainReceiverFactory proxy,) = _deployProxyToRoot(leaf, ownerKey, true);

        bytes32[] memory emptyProof = new bytes32[](0);
        bytes memory signature = abi.encode(owner, emptyProof);

        bytes4 result = proxy.isValidSignature(signingHash, signature);
        assertEq(result, MAGIC_VALUE, "Correct root+owner should return magic value");
    }

    /// @notice VDR-03: wrong owner returns false
    function test_VDR03_wrongOwner_returnsFalse() public {
        bytes32 signingHash = keccak256(abi.encode("signing_hash_vdr3"));
        bytes32 root = _hashLeaf(signingHash);
        uint256 correctOwnerKey = uint256(keccak256(abi.encode("correct_owner")));
        address correctOwner = vm.addr(correctOwnerKey);
        address wrongOwner = vm.addr(uint256(keccak256(abi.encode("wrong_owner"))));

        (ICrossChainReceiverFactory proxy,) = _deployProxyToRoot(root, correctOwnerKey, true);

        bytes32[] memory emptyProof = new bytes32[](0);
        bytes memory signature = abi.encode(wrongOwner, emptyProof);

        bytes4 result = proxy.isValidSignature(signingHash, signature);
        assertEq(result, INVALID_SIG, "Wrong owner should return invalid");
    }


    /// @notice SIG-07a: valid proof but for different proxy address returns invalid
    function test_SIG07a_validProofDifferentProxy_returnsInvalid() public {
        bytes32 signingHash = keccak256(abi.encode("sig07a_hash"));
        bytes32 leaf = _hashLeaf(signingHash);

        uint256 ownerKey = uint256(keccak256(abi.encode("sig07a_owner")));
        address owner = vm.addr(ownerKey);

        (ICrossChainReceiverFactory proxy1,) = _deployProxyToRoot(leaf, ownerKey, true);

        bytes32 differentRoot = keccak256(abi.encode("different_root"));
        (ICrossChainReceiverFactory proxy2,) = _deployProxyToRoot(differentRoot, ownerKey, true);

        bytes32[] memory emptyProof = new bytes32[](0);
        bytes memory signature = abi.encode(owner, emptyProof);

        bytes4 result = proxy2.isValidSignature(signingHash, signature);
        assertEq(result, INVALID_SIG, "Valid proof for different proxy should fail");
    }

    /// @notice SIG-11: valid ERC7739 signature but owner changed since signing returns invalid
    function test_SIG11_ownerChanged_returnsInvalid() public {
        uint256 originalOwnerKey = uint256(keccak256(abi.encode("sig11_original")));
        uint256 newOwnerKey = uint256(keccak256(abi.encode("sig11_new")));
        address newOwner = vm.addr(newOwnerKey);

        (ICrossChainReceiverFactory proxy, address originalOwner) =
            _deployProxy(keccak256(abi.encode("sig11")), originalOwnerKey);

        bytes32 appDomainSep = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode("contents"));
        string memory contentsDescriptor = "TestStruct(uint256 value)";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(originalOwnerKey, address(proxy), appDomainSep, contentsHash, contentsDescriptor);

        bytes4 result1 = proxy.isValidSignature(signedHash, signature);
        assertEq(result1, MAGIC_VALUE, "Should be valid with original owner");

        vm.prank(originalOwner);
        proxy.transferOwnership(newOwner);
        vm.prank(newOwner);
        ITwoStepOwnable(address(proxy)).acceptOwnership();

        bytes4 result2 = proxy.isValidSignature(signedHash, signature);
        assertEq(result2, INVALID_SIG, "Should be invalid after owner change");
    }

    /// @notice SIG-12b: signature.length == 64, first word has non-zero upper 96 bits takes ERC7739 path
    function test_SIG12b_64Bytes_dirtyFirstWord_ERC7739Path() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256(abi.encode("sig12b")));

        bytes memory signature = new bytes(64);
        signature[0] = 0xff;
        for (uint256 i = 1; i < 64; i++) {
            signature[i] = bytes1(uint8(i));
        }

        bytes32 hash = keccak256(abi.encode("test"));
        bytes4 result = proxy.isValidSignature(hash, signature);
        assertEq(result, INVALID_SIG, "64-byte dirty should go to ERC7739 path and fail");
    }

    /// @notice OWN-09: owner can transfer via multicall (self-call)
    function test_OWN09_transferViaMulticall_succeeds() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("own09_owner")));
        address newPending = address(0x9999);
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("own09")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = address(proxy);
        calls[0].data = abi.encodeCall(proxy.transferOwnership, (newPending));

        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, owner);
        bytes memory signature = _signCompact(ownerKey, signingHash);

        vm.prank(owner);
        proxy.metaTx(calls, 0, nonce, deadline, signature);

        assertEq(ITwoStepOwnable(address(proxy)).pendingOwner(), newPending, "Should have new pending owner");
    }

    // =========================================================================
    // TESTS - Nonce Management (NON-01, NON-05 to NON-06)
    // =========================================================================

    /// @notice NON-01: reads from Permit2.nonceBitmap at correct word position
    function test_NON01_readsCorrectWordPosition() public {
        // Use the same low 8 bits to ensure the same bit position across word boundaries.
        uint256 ownerKey = uint256(keccak256(abi.encode("non01_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("non01")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 deadline = block.timestamp + 1000;

        uint256 nonce1 = 0;
        bytes32 signingHash1 = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce1, deadline, owner);
        bytes memory signature1 = _signCompact(ownerKey, signingHash1);
        proxy.metaTx(calls, 0, nonce1, deadline, signature1);

        uint256 nonce2 = 256;
        bytes32 signingHash2 = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce2, deadline, owner);
        bytes memory signature2 = _signCompact(ownerKey, signingHash2);
        proxy.metaTx(calls, 0, nonce2, deadline, signature2);
    }

    /// @notice NON-05: Permit2 nonceBitmap staticcall fails - bubbles revert
    function test_NON05_permit2NonceBitmapFails_bubbles() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("non05_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("non05")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 42;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, owner);
        bytes memory signature = _signCompact(ownerKey, signingHash);

        // Mock Permit2: nonceBitmap reverts.
        bytes memory revertBytecode = hex"5f5ffd";
        vm.etch(PERMIT2, revertBytecode);

        vm.prank(owner);
        vm.expectRevert();
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    /// @notice NON-06: Permit2 invalidateUnorderedNonces call fails - bubbles revert
    function test_NON06_permit2InvalidateNoncesFails_bubbles() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("non06_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("non06")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 42;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, owner);
        bytes memory signature = _signCompact(ownerKey, signingHash);

        // Mock Permit2: nonceBitmap returns 0; invalidateUnorderedNonces reverts.
        bytes memory mockBytecode = hex"5f3560e01c634fe02b44146011575f5ffd5b5f5f525f6020f3";
        vm.etch(PERMIT2, mockBytecode);

        vm.prank(owner);
        vm.expectRevert();
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    /// @notice CLN-05: proxy calls itself via multicall selfdestructs
    function test_CLN05_proxyCallsItself_succeeds() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("cln05_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("cln05")), ownerKey);

        address payable beneficiary = payable(address(0xDEAD));

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = address(proxy);
        calls[0].data = abi.encodeCall(proxy.cleanup, (beneficiary));

        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        // Use simple mode helper that includes owner in nonce for hash computation
        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, owner);
        bytes memory signature = _signCompact(ownerKey, signingHash);

        vm.prank(owner);
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    /// @notice PAT-05: token.balanceOf drives patchBytes calculation
    function test_PAT05_balanceOfReturnsBalance() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("pat05_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("pat05")), ownerKey);

        address mockToken = _deployMockERC20();
        address mockTarget = _deployMockTarget();

        uint256 expectedPatchBytes = 500 ether;
        uint256 ppm = 500_000;
        bytes memory data = abi.encodeWithSignature("echo(uint256)", uint256(0));

        vm.prank(owner);
        bytes memory result = proxy.call(payable(mockTarget), IERC20(mockToken), ppm, 4, data);

        uint256 echoed = abi.decode(result, (uint256));
        assertEq(echoed, expectedPatchBytes, "Patched value should be 50% of token balance");
    }

    /// @notice PAT-10: ppm * balance overflow reverts with Panic(0x11)
    function test_PAT10_ppmOverflow_reverts() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("pat10_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("pat10")), ownerKey);

        address mockTarget = _deployMockTarget();

        vm.deal(address(proxy), type(uint256).max);

        uint256 ppm = 2;
        bytes memory data = abi.encodeWithSignature("echo(uint256)", uint256(0));

        vm.prank(owner);
        vm.expectRevert(abi.encodeWithSelector(bytes4(0x4e487b71), uint256(0x11)));
        proxy.call(payable(mockTarget), NATIVE, ppm, 4, data);
    }

    /// @notice PAT-13: ppm > 1_000_000 results in patchBytes > balance
    function test_PAT13_ppmOver100Percent() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("pat13_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("pat13")), ownerKey);

        address mockTarget = _deployMockTarget();
        vm.deal(address(proxy), 1 ether);

        uint256 ppm = 2_000_000;
        bytes memory data = abi.encodeWithSignature("echo(uint256)", uint256(0));

        vm.prank(owner);
        vm.expectRevert();
        proxy.call(payable(mockTarget), NATIVE, ppm, 4, data);
    }

    /// @notice PAT-14: patched bytes at offset contain correct value
    function test_PAT14_patchedBytesCorrect() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("pat14_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("pat14")), ownerKey);

        address mockTarget = _deployMockTarget();
        vm.deal(address(proxy), 1 ether);

        uint256 ppm = 1_000_000;
        uint256 expectedPatchBytes = 1 ether;

        bytes memory data = abi.encodeWithSignature("echo(uint256)", uint256(0));

        vm.prank(owner);
        bytes memory result = proxy.call(payable(mockTarget), NATIVE, ppm, 4, data);

        uint256 returnedValue = abi.decode(result, (uint256));
        assertEq(returnedValue, expectedPatchBytes, "Patched value should be 1 ether");
    }

    /// @notice INT-17: metaTx signature replay on different proxy fails
    function test_INT17_metaTxReplayDifferentProxy_fails() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("int17_owner")));

        (ICrossChainReceiverFactory proxy1,) =
            _deployProxy(keccak256(abi.encode("int17_proxy1")), ownerKey);
        (ICrossChainReceiverFactory proxy2, address owner) =
            _deployProxy(keccak256(abi.encode("int17_proxy2")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash1 = _computeMetaTxSigningHash(address(proxy1), calls, 0, nonce, deadline);
        bytes memory signature1 = _signCompact(ownerKey, signingHash1);

        vm.expectRevert(); // InvalidSigner - domain separator differs
        proxy2.metaTx(calls, 0, nonce, deadline, signature1);
    }

    /// @notice MTX-18: multicall reverts - bubbles the revert
    function test_MTX18_multicallReverts_bubbles() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("mtx18_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("mtx18")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = address(0);
        calls[0].data = hex"deadbeef";
        calls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;

        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHash(address(proxy), calls, 0, nonce, deadline);
        bytes memory signature = _signCompact(ownerKey, signingHash);

        vm.expectRevert();
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    /// @notice MTX-29: WETH balance insufficient to cover shortfall reverts
    function test_MTX29_wethInsufficient_reverts() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("mtx29_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("mtx29")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = address(0xBEEF);
        calls[0].value = 1 ether;
        calls[0].data = "";

        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHash(address(proxy), calls, 0, nonce, deadline);
        bytes memory signature = _signCompact(ownerKey, signingHash);

        vm.expectRevert();
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    /// @notice RCV-03: WETH.deposit reverts - bubbles revert
    /// @dev Tests that when ETH is sent to the proxy and WETH.deposit fails, the revert bubbles up
    function test_RCV03_wethDepositReverts_bubbles() public {
        // Deploy a proxy first (using normal WETH)
        uint256 ownerKey = uint256(keccak256("rcv03_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("rcv03_action"), ownerKey);

        // Save original WETH bytecode
        bytes memory originalWethCode = address(WETH).code;

        // Deploy broken WETH that reverts on any call (including deposit via fallback)
        // Bytecode: PUSH1 0x00, PUSH1 0x00, REVERT (unconditionally reverts with no data)
        bytes memory brokenWethCode = hex"60006000fd";
        vm.etch(address(WETH), brokenWethCode);

        // Create a random sender address (not WETH) that will trigger the receive() wrap path
        address randomSender = address(0xBEEFCAFE);
        vm.deal(randomSender, 1 ether);

        // Send ETH to proxy from non-WETH address
        vm.prank(randomSender);
        vm.expectRevert();
        (bool success,) = address(proxy).call{value: 0.5 ether}("");

        // Restore original WETH code for subsequent tests
        vm.etch(address(WETH), originalWethCode);
    }

    // =========================================================================
    // TESTS - Section: _verifySimpleSignature (VSS-01 to VSS-07)
    // These are tested indirectly through metaTx since _verifySimpleSignature is internal
    // =========================================================================

    /// @notice VSS-02: signature length != 64 reverts with Panic(0x32)
    function test_VSS02_signatureLengthNot64_reverts() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("vss02_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("vss02")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, owner);
        bytes memory fullSig = _signCompact(ownerKey, signingHash);
        bytes memory shortSig = new bytes(63);
        for (uint256 i = 0; i < 63; i++) {
            shortSig[i] = fullSig[i];
        }

        vm.prank(owner);
        vm.expectRevert(abi.encodeWithSelector(bytes4(0x4e487b71), uint256(0x32))); // Panic(0x32) array out-of-bounds
        proxy.metaTx(calls, 0, nonce, deadline, shortSig);
    }

    /// @notice VSS-06: invalid signature - reverts with InvalidSigner
    function test_VSS06_invalidSignature_reverts() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("vss06_owner")));
        uint256 wrongKey = uint256(keccak256(abi.encode("vss06_wrong")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("vss06")), ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        // Sign with wrong key
        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, owner);
        bytes memory signature = _signCompact(wrongKey, signingHash);

        vm.prank(owner);
        vm.expectRevert(abi.encodeWithSelector(bytes4(0x815e1d64))); // InvalidSigner
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    /// @notice VSS-07: owner == address(0) reverts
    function test_VSS07_ownerZero_reverts() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("vss07_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("vss07")), ownerKey);

        vm.prank(owner);
        ITwoStepOwnable(address(proxy)).renounceOwnership();
        assertEq(proxy.owner(), address(0), "Owner should be address(0) after renouncing");

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 7;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(
            address(proxy), calls, 0, nonce, deadline, address(0)
        );
        bytes memory signature = _signCompact(ownerKey, signingHash);

        vm.prank(owner);
        vm.expectRevert(abi.encodeWithSelector(bytes4(0x815e1d64))); // InvalidSigner
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    // =========================================================================
    // TESTS - Section: MultiCall Context (CTX-01 to CTX-07)
    // Testing ERC-2771 forwarding through EIP150_MULTICALL_ADDRESS
    // =========================================================================

    /// @notice CTX-06: via MULTICALL strips appended sender from _msgData
    function test_CTX06_multicall_stripsMsgData() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("ctx06_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("ctx06")), ownerKey);

        IMultiCall.Call[] memory innerCalls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), innerCalls, contextdepth, nonce, deadline);

        bytes memory metaTxCalldata = abi.encodeWithSelector(
            ICrossChainReceiverFactory.metaTx.selector,
            innerCalls,
            contextdepth,
            nonce,
            deadline,
            signature
        );

        IMultiCall.Call[] memory outerCalls = new IMultiCall.Call[](1);
        outerCalls[0].target = address(proxy);
        outerCalls[0].data = metaTxCalldata;
        outerCalls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;

        uint256 argsLength = metaTxCalldata.length - 4; // exclude metaTx selector
        bytes memory expectedCallToMulticall = new bytes(4 + argsLength);

        expectedCallToMulticall[0] = 0x66;
        expectedCallToMulticall[1] = 0x9a;
        expectedCallToMulticall[2] = 0x7d;
        expectedCallToMulticall[3] = 0x5e;

        for (uint256 i = 0; i < argsLength; i++) {
            expectedCallToMulticall[4 + i] = metaTxCalldata[4 + i];
        }

        vm.expectCall(EIP150_MULTICALL_ADDRESS, expectedCallToMulticall);

        vm.prank(owner);
        IMultiCall.Result[] memory results = IMultiCall(payable(EIP150_MULTICALL_ADDRESS)).multicall(outerCalls, 0);

        assertTrue(results[0].success, "metaTx call should succeed");
    }

    /// @notice MTX-09: valid Merkle proof signature path succeeds
    /// @dev Uses a 2-leaf tree to exercise non-empty proofs.
    function test_MTX09_validMerkleProof_succeeds() public {
        uint256 ownerKey = uint256(keccak256("mtx09"));
        address owner = vm.addr(ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = (uint256(uint160(owner)) << 96) | 42;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashMerkleMode(calls, contextdepth, nonce, deadline);
        bytes32 metaTxLeaf = _hashLeaf(signingHash);

        bytes32 otherAction = keccak256("other_action_for_mtx09");
        bytes32 otherLeaf = _hashLeaf(otherAction);

        bytes32[] memory leaves = new bytes32[](2);
        leaves[0] = metaTxLeaf;
        leaves[1] = otherLeaf;
        (bytes32 root, bytes32[][] memory proofs) = _buildMerkleTree(leaves);

        (ICrossChainReceiverFactory proxy,) = _deployProxyToRoot(root, ownerKey, true);

        bytes32[] memory proof = proofs[0];
        bytes memory signature = abi.encode(proof);

        IMultiCall.Result[] memory results = proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
        assertEq(results.length, 0);
    }

    /// @notice MTX-10: invalid Merkle proof reverts with InvalidSigner
    /// @dev Deploy with one root, provide a mismatched proof.
    function test_MTX10_invalidMerkleProof_reverts() public {
        uint256 ownerKey = uint256(keccak256("mtx10"));
        address owner = vm.addr(ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonce = (uint256(uint160(owner)) << 96) | 100;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashMerkleMode(calls, contextdepth, nonce, deadline);
        bytes32 metaTxLeaf = _hashLeaf(signingHash);

        (ICrossChainReceiverFactory proxy,) = _deployProxyToRoot(metaTxLeaf, ownerKey, true);

        bytes32[] memory invalidProof = new bytes32[](1);
        invalidProof[0] = keccak256("invalid_proof_element_for_mtx10");
        bytes memory signature = abi.encode(invalidProof);

        vm.expectRevert(abi.encodeWithSelector(bytes4(0x815e1d64))); // InvalidSigner
        proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
    }

    /// @notice MTX-11: wrong original owner in nonce reverts
    /// @dev Deploy with owner A in nonce, call with owner B.
    function test_MTX11_wrongOwnerInNonce_reverts() public {
        uint256 ownerKeyA = uint256(keccak256("mtx11_ownerA"));
        address ownerA = vm.addr(ownerKeyA);

        uint256 ownerKeyB = uint256(keccak256("mtx11_ownerB"));
        address ownerB = vm.addr(ownerKeyB);
        require(ownerA != ownerB, "owners must differ");

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        uint256 nonceWithOwnerA = (uint256(uint160(ownerA)) << 96) | 1;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashMerkleMode(calls, contextdepth, nonceWithOwnerA, deadline);
        bytes32 leaf = _hashLeaf(signingHash);

        (ICrossChainReceiverFactory proxy,) = _deployProxyToRoot(leaf, ownerKeyA, true);

        uint256 nonceWithOwnerB = (uint256(uint160(ownerB)) << 96) | 1;

        bytes32[] memory proof = new bytes32[](0);
        bytes memory signature = abi.encode(proof);

        vm.expectRevert(abi.encodeWithSelector(bytes4(0x815e1d64))); // InvalidSigner
        proxy.metaTx(calls, contextdepth, nonceWithOwnerB, deadline, signature);
    }

    /// @notice MTX-26: relayer == msg.sender via MULTICALL forwarding
    function test_MTX26_relayerViaMulticall_succeeds() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("mtx26_owner")));
        (ICrossChainReceiverFactory proxy, address owner) =
            _deployProxy(keccak256(abi.encode("mtx26")), ownerKey);

        vm.deal(address(proxy), 1 ether);

        address relayer = address(0xABCD);

        // Deadline with relayer address in upper 160 bits
        uint256 deadline = (uint256(uint160(relayer)) << 96) | uint96(block.timestamp + 1000);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 1;

        // Sign with full deadline (including relayer in upper bits)
        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, owner);
        bytes memory signature = _signCompact(ownerKey, signingHash);

        // Encode the metaTx call for multicall
        bytes memory metaTxData = abi.encodeWithSelector(
            ICrossChainReceiverFactory.metaTx.selector,
            calls,
            0,
            nonce,
            deadline,
            signature
        );

        IMultiCall.Call[] memory multicallCalls = new IMultiCall.Call[](1);
        multicallCalls[0].target = address(proxy);
        multicallCalls[0].data = metaTxData;
        multicallCalls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;

        // When called via EIP150_MULTICALL_ADDRESS, the relayer address is extracted from context
        vm.prank(relayer);
        IMultiCall.Result[] memory results = IMultiCall(payable(EIP150_MULTICALL_ADDRESS)).multicall(multicallCalls, 0);
        assertTrue(results[0].success);
    }

    // =========================================================================
    // TESTS - MTX-34 to MTX-42: Missing WNATIVE Handling in metaTx()
    // =========================================================================

    /// @notice MTX-35: `_HAS_WNATIVE=false`, staticcall to address(0) succeeds  wrappedBalance = 0
    function test_MTX35_missingWnative_staticcallToZero_succeeds() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256("mtx35_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxyMissingWnative(keccak256("mtx35_root"), ownerKey, true);

        vm.deal(address(proxy), 0.5 ether);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0] = IMultiCall.Call({
            target: address(0xCAFE),
            revertPolicy: IMultiCall.RevertPolicy.CONTINUE,
            value: 1 ether,
            data: ""
        });

        vm.mockCall(
            address(0),
            abi.encodeWithSelector(IERC20.balanceOf.selector, address(proxy)),
            abi.encode(10 ether)
        );

        uint256 nonce = 35;
        uint256 deadline = block.timestamp + 1000;
        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, 0, nonce, deadline);

        uint256 targetBefore = calls[0].target.balance;
        IMultiCall.Result[] memory results = proxy.metaTx(calls, 0, nonce, deadline, signature);

        assertEq(results.length, 1);
        assertFalse(results[0].success, "Call should fail due to clamped value");
        assertEq(calls[0].target.balance, targetBefore, "Target should receive 0");
        assertEq(address(proxy).balance, 0.5 ether, "Proxy should recover clamped ETH");
        assertEq(address(EIP150_MULTICALL_ADDRESS).balance, 0, "Multicall should not retain ETH");

        vm.clearMockedCalls();
    }

    /// @notice MTX-38: `_HAS_WNATIVE=true`, balanceOf staticcall fails  reverts
    function test_MTX38_hasWnative_balanceOfReverts_reverts() public {
        uint256 ownerKey = uint256(keccak256("mtx38_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("mtx38_root"), ownerKey);

        vm.deal(address(proxy), 0.1 ether);

        bytes memory originalWethCode = address(WETH).code;
        bytes memory brokenWethCode = hex"60006000fd";
        vm.etch(address(WETH), brokenWethCode);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0] = IMultiCall.Call({
            target: address(0xCAFE),
            revertPolicy: IMultiCall.RevertPolicy.CONTINUE,
            value: 1 ether,
            data: ""
        });

        uint256 nonce = 38;
        uint256 deadline = block.timestamp + 1000;
        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, 0, nonce, deadline);

        vm.expectRevert();
        proxy.metaTx(calls, 0, nonce, deadline, signature);

        vm.etch(address(WETH), originalWethCode);
    }

    /// @notice MTX-40: `_HAS_WNATIVE=false`, value clamped  multicall forwards less than requested
    function test_MTX40_missingWnative_valueClamped_multicallForwardsLess() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256("mtx40_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxyMissingWnative(keccak256("mtx40_root"), ownerKey, true);

        vm.deal(address(proxy), 0.3 ether);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](2);
        calls[0] = IMultiCall.Call({
            target: address(0x1111),
            revertPolicy: IMultiCall.RevertPolicy.CONTINUE,
            value: 0.1 ether,
            data: ""
        });
        calls[1] = IMultiCall.Call({
            target: address(0x2222),
            revertPolicy: IMultiCall.RevertPolicy.CONTINUE,
            value: 0.4 ether,
            data: ""
        });

        uint256 nonce = 40;
        uint256 deadline = block.timestamp + 1000;
        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, 0, nonce, deadline);

        uint256 target1Before = calls[0].target.balance;
        uint256 target2Before = calls[1].target.balance;
        IMultiCall.Result[] memory results = proxy.metaTx(calls, 0, nonce, deadline, signature);

        assertEq(results.length, 2);
        assertTrue(results[0].success, "First call should succeed within clamped value");
        assertFalse(results[1].success, "Second call should fail due to insufficient value");
        assertEq(calls[0].target.balance - target1Before, 0.1 ether, "First target receives value");
        assertEq(calls[1].target.balance, target2Before, "Second target receives 0");
        assertEq(address(proxy).balance, 0.2 ether, "Proxy should recover remaining value");
    }

    /// @notice MTX-41: `_HAS_WNATIVE=false`, total value == 0 skips unwrap block
    function test_MTX41_missingWnative_zeroValue_skipsUnwrap() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256("mtx41_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxyMissingWnative(keccak256("mtx41_root"), ownerKey, true);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 41;
        uint256 deadline = block.timestamp + 1000;

        vm.mockCallRevert(
            address(0),
            abi.encodeWithSelector(IERC20.balanceOf.selector, address(proxy)),
            bytes("NO")
        );

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, 0, nonce, deadline);

        IMultiCall.Result[] memory results = proxy.metaTx(calls, 0, nonce, deadline, signature);
        assertEq(results.length, 0);

        vm.clearMockedCalls();
    }

    /// @notice MTX-44: signature computed using sentinel target  signature verifies correctly
    function test_MTX44_signatureWithSentinel_verifiesCorrectly() public {
        uint256 ownerKey = uint256(keccak256("mtx44_owner"));
        address owner = vm.addr(ownerKey);

        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256(abi.encode("mtx44")), ownerKey);

        IMultiCall.Call[] memory sentinelCalls = new IMultiCall.Call[](1);
        sentinelCalls[0].target = ADDRESS_THIS_SENTINEL;
        sentinelCalls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        sentinelCalls[0].value = 0;
        sentinelCalls[0].data = abi.encodeWithSelector(IOwnable.owner.selector);

        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes memory correctSignature =
            _signMetaTxSimple(ownerKey, address(proxy), sentinelCalls, contextdepth, nonce, deadline);

        IMultiCall.Call[] memory proxyCalls = new IMultiCall.Call[](1);
        proxyCalls[0].target = address(proxy);
        proxyCalls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        proxyCalls[0].value = 0;
        proxyCalls[0].data = abi.encodeWithSelector(IOwnable.owner.selector);

        bytes memory wrongSignature =
            _signMetaTxSimple(ownerKey, address(proxy), proxyCalls, contextdepth, nonce, deadline);

        vm.expectRevert();
        proxy.metaTx(sentinelCalls, contextdepth, nonce, deadline, wrongSignature);

        IMultiCall.Result[] memory results = proxy.metaTx(sentinelCalls, contextdepth, nonce, deadline, correctSignature);
        assertEq(results.length, 1, "Should have one result");
        assertTrue(results[0].success, "Call with correct signature should succeed");
    }

    /// @notice MTX-46: multiple calls with mix of sentinel and regular targets  only sentinel targets replaced
    function test_MTX46_mixedTargets_onlySentinelReplaced() public {
        uint256 ownerKey = uint256(keccak256("mtx46_owner"));
        address owner = vm.addr(ownerKey);

        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256(abi.encode("mtx46")), ownerKey);

        address regularTarget = _deployMockTarget();
        require(regularTarget != address(proxy), "target must differ from proxy");
        require(regularTarget != ADDRESS_THIS_SENTINEL, "target must not be sentinel");

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](3);

        calls[0].target = ADDRESS_THIS_SENTINEL;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        calls[0].value = 0;
        calls[0].data = abi.encodeWithSelector(IOwnable.owner.selector);

        uint256 echoValue = 42;
        calls[1].target = regularTarget;
        calls[1].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        calls[1].value = 0;
        calls[1].data = abi.encodeWithSelector(MockTarget.echo.selector, echoValue);

        calls[2].target = ADDRESS_THIS_SENTINEL;
        calls[2].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        calls[2].value = 0;
        calls[2].data = abi.encodeWithSelector(ITwoStepOwnable.pendingOwner.selector);

        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        vm.expectCall(address(proxy), abi.encodeWithSelector(IOwnable.owner.selector));
        vm.expectCall(regularTarget, abi.encodeWithSelector(MockTarget.echo.selector, echoValue));
        vm.expectCall(address(proxy), abi.encodeWithSelector(ITwoStepOwnable.pendingOwner.selector));

        IMultiCall.Result[] memory results = proxy.metaTx(calls, contextdepth, nonce, deadline, signature);

        assertEq(results.length, 3, "Should have three results");
        assertTrue(results[0].success, "Call 0 (sentinel->owner) should succeed");
        assertTrue(results[1].success, "Call 1 (regular->echo) should succeed");
        assertTrue(results[2].success, "Call 2 (sentinel->pendingOwner) should succeed");

        address returnedOwner = abi.decode(results[0].data, (address));
        assertEq(returnedOwner, owner, "Call 0 should have executed on proxy, returning correct owner");

        uint256 returnedEcho = abi.decode(results[1].data, (uint256));
        assertEq(returnedEcho, echoValue, "Call 1 should have executed on MockTarget, returning echoed value");

        address returnedPending = abi.decode(results[2].data, (address));
        assertEq(returnedPending, address(0), "Call 2 should have executed on proxy, returning zero pending owner");
    }

    /// @notice MTX-50: Sentinel target with non-zero value field  target replaced AND value correctly forwarded
    function test_MTX50_sentinelTargetWithValue_valueForwarded() public {
        uint256 ownerKey = uint256(keccak256("mtx50_owner"));
        address owner = vm.addr(ownerKey);

        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256(abi.encode("mtx50")), ownerKey);
        assertEq(proxy.owner(), owner, "Initial owner should be set");

        uint256 fundAmount = 2 ether;
        vm.deal(address(proxy), fundAmount);
        assertEq(address(proxy).balance, fundAmount, "Proxy should have ETH balance");

        uint256 wethBalanceBefore = WETH.balanceOf(address(proxy));
        assertEq(wethBalanceBefore, 0, "Proxy should start with zero WETH");

        uint256 sendValue = 0.5 ether;

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = ADDRESS_THIS_SENTINEL;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        calls[0].value = sendValue;
        calls[0].data = "";

        uint256 contextdepth = 0;
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, contextdepth, nonce, deadline);

        vm.expectCall(address(proxy), sendValue, "");

        vm.prank(owner);
        IMultiCall.Result[] memory results = proxy.metaTx(calls, contextdepth, nonce, deadline, signature);

        assertEq(results.length, 1, "Should have one result");
        assertTrue(results[0].success, "Call with value to sentinel target should succeed");

        uint256 wethBalanceAfter = WETH.balanceOf(address(proxy));
        assertEq(wethBalanceAfter, sendValue, "Proxy WETH balance should equal sent value");

        assertEq(address(proxy).balance, fundAmount - sendValue, "Proxy ETH should decrease by wrapped amount");
    }

    /// @notice MTX-52: Merkle path metaTx with empty proof array  leaf unchanged, verifies against single-leaf root
    function test_MTX52_merklePath_emptyProof_singleLeafTreeVerifies() public {
        uint256 ownerKey = uint256(keccak256("mtx52_owner"));
        address owner = vm.addr(ownerKey);

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = ADDRESS_THIS_SENTINEL;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;
        calls[0].value = 0;
        calls[0].data = abi.encodeWithSelector(IOwnable.owner.selector);

        uint256 contextdepth = 0;
        uint256 nonce = (uint256(uint160(owner)) << 96) | 42;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashMerkleMode(calls, contextdepth, nonce, deadline);
        bytes32 leaf = _hashLeaf(signingHash);

        (ICrossChainReceiverFactory proxy,) = _deployProxyToRoot(leaf, ownerKey, true);
        assertEq(proxy.owner(), owner, "Initial owner should be set");

        bytes32[] memory proof = new bytes32[](0);
        bytes memory signature = abi.encode(proof);

        vm.expectCall(address(proxy), abi.encodeWithSelector(IOwnable.owner.selector));

        IMultiCall.Result[] memory results = proxy.metaTx(calls, contextdepth, nonce, deadline, signature);

        assertEq(results.length, 1, "Should have one result");
        assertTrue(results[0].success, "Merkle path with empty proof should succeed for single-leaf tree");

        address returnedOwner = abi.decode(results[0].data, (address));
        assertEq(returnedOwner, owner, "Call should have executed on proxy via sentinel replacement");
    }

    /// @notice INT-03: ownership transfer then metaTx (simple) uses new owner
    function test_INT03_ownershipTransferThenSimpleMetaTx() public {
        uint256 originalOwnerKey = uint256(keccak256(abi.encode("int03_original")));
        uint256 newOwnerKey = uint256(keccak256(abi.encode("int03_new")));
        address newOwner = vm.addr(newOwnerKey);

        (ICrossChainReceiverFactory proxy, address originalOwner) =
            _deployProxy(keccak256(abi.encode("int03")), originalOwnerKey);

        vm.prank(originalOwner);
        proxy.transferOwnership(newOwner);
        vm.prank(newOwner);
        ITwoStepOwnable(address(proxy)).acceptOwnership();

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 nonce = 1;
        uint256 deadline = block.timestamp + 1000;

        bytes32 signingHash = _computeMetaTxSigningHashSimpleMode(address(proxy), calls, 0, nonce, deadline, newOwner);
        bytes memory signature = _signCompact(newOwnerKey, signingHash);

        vm.prank(newOwner);
        proxy.metaTx(calls, 0, nonce, deadline, signature);
    }

    /// @notice INT-04: ownership transfer then metaTx (Merkle) still validates original owner
    /// @dev After ownership transfer, Merkle mode metaTx still validates against the
    ///      original owner encoded in the nonce (used to derive the deployment salt)
    function test_INT04_ownershipTransferMerkleStillValidatesOriginal() public {
        uint256 originalOwnerKey = uint256(keccak256("int04_original"));
        address originalOwner = vm.addr(originalOwnerKey);
        uint256 newOwnerKey = uint256(keccak256("int04_new"));
        address newOwner = vm.addr(newOwnerKey);
        require(originalOwner != newOwner, "owners must differ");

        // Set up metaTx parameters with original owner encoded in nonce (Merkle mode)
        IMultiCall.Call[] memory calls = new IMultiCall.Call[](0);
        uint256 contextdepth = 0;
        // Merkle mode: pack original owner into upper 160 bits of nonce
        uint256 nonce = (uint256(uint160(originalOwner)) << 96) | 1;
        uint256 deadline = block.timestamp + 1000;

        // Compute the signing hash using Merkle mode (with sentinel domain separator)
        bytes32 signingHash = _computeMetaTxSigningHashMerkleMode(calls, contextdepth, nonce, deadline);
        bytes32 leaf = _hashLeaf(signingHash);

        // Deploy proxy with this leaf as the root (single-leaf tree)
        (ICrossChainReceiverFactory proxy,) = _deployProxyToRoot(leaf, originalOwnerKey, true);

        // Transfer ownership to newOwner
        vm.prank(originalOwner);
        proxy.transferOwnership(newOwner);
        vm.prank(newOwner);
        ITwoStepOwnable(address(proxy)).acceptOwnership();

        // Verify ownership has changed
        assertEq(proxy.owner(), newOwner, "Owner should be newOwner");

        // Create Merkle proof (empty for single-leaf tree)
        bytes32[] memory proof = new bytes32[](0);
        bytes memory signature = abi.encode(proof);

        // Execute the metaTx - should still succeed because Merkle mode validates
        // against the original owner encoded in the nonce, not the current owner
        IMultiCall.Result[] memory results = proxy.metaTx(calls, contextdepth, nonce, deadline, signature);
        assertEq(results.length, 0, "Empty calls should produce empty results");
    }

    /// @notice INT-09: deploy with cleanup  redeploy same params - succeeds (address reusable)
    function test_INT09_cleanupThenRedeploy_succeeds() public {
        // After cleanup (in same tx), the address can be reused for new deployment.
        bytes32 root = keccak256(abi.encode("int09_root"));

        // Deploy and immediately cleanup in same pattern
        ICrossChainReceiverFactory proxy1 = factory.deploy(root, false, defaultOwner);

        // The cleanup happened in deploy, so try deploying again with different owner.
        address newOwner = address(0xABCD);
        bytes32 root2 = keccak256(abi.encode("int09_root2"));
        ICrossChainReceiverFactory proxy2 = factory.deploy(root2, true, newOwner);

        assertTrue(address(proxy1) != address(proxy2));
    }

    /// @notice CLN-10: cleanup() called on factory reverts
    /// @dev onlyProxy/_requireOwner fails in the factory context.
    function test_CLN10_cleanupOnFactory_reverts() public {
        address payable beneficiary = payable(address(0xBEEF));

        vm.expectRevert();
        factory.cleanup(beneficiary);
    }

    // =========================================================================
    // V77: _verifyERC7739NestedTypedSignature
    // =========================================================================

    /// @notice V77-01: correct layout with valid lengths parses correctly
    function test_V77_01_correctLayout_validLengths_parsesCorrectly() public {
        uint256 ownerKey = uint256(keccak256("v77_01_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_01_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("Data(uint256 x)"), uint256(42)));
        string memory contentsDescriptor = "Data(uint256 x)";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(ownerKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes4 result = proxy.isValidSignature(signedHash, signature);
        assertEq(result, MAGIC_VALUE);
    }

    /// @notice V77-02: malformed layout (wrong total length) returns false
    function test_V77_02_malformedLayout_wrongLength_returnsFalse() public {
        uint256 ownerKey = uint256(keccak256("v77_02_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_02_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("Data(uint256 x)"), uint256(42)));

        bytes memory badSig = abi.encodePacked(
            bytes32(uint256(1)), // r
            bytes32(uint256(2)), // vs
            appDomainSeparator,
            contentsHash,
            "Data(uint256 x)",
            uint16(100)
        );

        bytes32 signedHash = _hashEip712(appDomainSeparator, contentsHash);
        bytes4 result = proxy.isValidSignature(signedHash, badSig);
        assertEq(result, INVALID_SIG);
    }

    /// @notice V77-04: reconstructed hash doesn't match returns false
    function test_V77_04_reconstructedHashMismatch_returnsFalse() public {
        uint256 ownerKey = uint256(keccak256("v77_04_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_04_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("Data(uint256 x)"), uint256(42)));
        string memory contentsDescriptor = "Data(uint256 x)";

        (bytes memory signature,) =
            _buildERC7739Signature(ownerKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes32 wrongHash = keccak256("wrong hash");
        bytes4 result = proxy.isValidSignature(wrongHash, signature);
        assertEq(result, INVALID_SIG);
    }

    /// @notice V77-04b: contentsDescription.length == 0 returns false
    function test_V77_04b_emptyContentsDescription_returnsFalse() public {
        uint256 ownerKey = uint256(keccak256("v77_04b_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_04b_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("Data(uint256 x)"), uint256(42)));

        bytes memory badSig = abi.encodePacked(
            bytes32(uint256(1)), // r
            bytes32(uint256(2)), // vs
            appDomainSeparator,
            contentsHash,
            uint16(0)
        );

        bytes32 signedHash = _hashEip712(appDomainSeparator, contentsHash);
        bytes4 result = proxy.isValidSignature(signedHash, badSig);
        assertEq(result, INVALID_SIG);
    }

    /// @notice V77-05: contentsName starting with lowercase [a-z] is INVALID per EIP-712
    function test_V77_05_contentsNameLowercase_invalid() public {
        uint256 ownerKey = uint256(keccak256("v77_05_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_05_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("myData(uint256 value)"), uint256(999)));
        string memory contentsDescriptor = "myData(uint256 value)";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(ownerKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes4 result = proxy.isValidSignature(signedHash, signature);
        assertEq(result, INVALID_SIG);
    }

    /// @notice V77-06a: contentsName starts with digit [0-9] is VALID per ERC-7739
    function test_V77_06a_contentsNameDigit_valid() public {
        uint256 ownerKey = uint256(keccak256("v77_06a_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_06a_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("1data(uint256 value)"), uint256(999)));
        string memory contentsDescriptor = "1data(uint256 value)";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(ownerKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes4 result = proxy.isValidSignature(signedHash, signature);
        assertEq(result, MAGIC_VALUE);
    }

    /// @notice V77-06b: contentsName starts with '(' is INVALID
    function test_V77_06b_contentsNameOpenParen_invalid() public {
        uint256 ownerKey = uint256(keccak256("v77_06b_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_06b_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("(test(uint256 a)"), uint256(1)));
        string memory contentsDescriptor = "(test(uint256 a)";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(ownerKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes4 result = proxy.isValidSignature(signedHash, signature);
        assertEq(result, INVALID_SIG);
    }

    /// @notice V77-08d: owner_ == address(0), invalid signature returns false
    function test_V77_08d_ownerZero_returnsFalse() public {
        uint256 ownerKey = uint256(keccak256("v77_08d_owner"));
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("v77_08d_action"), ownerKey);

        vm.prank(owner);
        ITwoStepOwnable(address(proxy)).renounceOwnership();

        assertEq(proxy.owner(), address(0));

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("test(uint256 a)"), uint256(3)));
        string memory contentsDescriptor = "test(uint256 a)";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(ownerKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes4 result = proxy.isValidSignature(signedHash, signature);
        assertEq(result, INVALID_SIG);
    }

    /// @notice V77-10a: explicit mode with multiple ')' in description - finds correct rightmost ')'
    function test_V77_10a_multipleParens_findsRightmost() public {
        uint256 ownerKey = uint256(keccak256("v77_10a_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_10a_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        // Explicit mode with nested parentheses exercises rightmost ')' parsing.
        bytes32 contentsHash = keccak256(
            abi.encode(keccak256("Nested(Inner(uint256 a))"), keccak256(abi.encode(keccak256("Inner(uint256 a)"), uint256(1))))
        );
        string memory contentsDescriptor = "Nested(Inner(uint256 a))Nested";

        (bytes memory signature, bytes32 signedHash) =
            _buildERC7739Signature(ownerKey, address(proxy), appDomainSeparator, contentsHash, contentsDescriptor);

        bytes4 result = proxy.isValidSignature(signedHash, signature);
        assertEq(result, MAGIC_VALUE);
    }

    /// @notice V77-10b: explicit mode with no ')' found - truncates incorrectly
    function test_V77_10b_noParen_truncatesIncorrectly() public {
        uint256 ownerKey = uint256(keccak256("v77_10b_owner"));
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("v77_10b_action"), ownerKey);

        bytes32 appDomainSeparator = keccak256(
            abi.encode(
                keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)"),
                keccak256("TestApp"),
                block.chainid,
                address(this)
            )
        );
        bytes32 contentsHash = keccak256(abi.encode(keccak256("BadType"), uint256(1)));
        string memory contentsDescriptor = "BadType";

        // Build signature manually since _buildERC7739Signature expects valid descriptor
        bytes memory sig = _signCompact(ownerKey, keccak256("dummy"));
        bytes memory badSig = abi.encodePacked(
            sig,
            appDomainSeparator,
            contentsHash,
            bytes(contentsDescriptor),
            uint16(bytes(contentsDescriptor).length)
        );

        bytes32 signedHash = _hashEip712(appDomainSeparator, contentsHash);
        bytes4 result = proxy.isValidSignature(signedHash, badSig);
        assertEq(result, INVALID_SIG);
    }

    /// @notice DEP-13: post-deployment call fails - cleanup reverts without data
    /// @dev cleanup() uses an empty-data revert on WETH call failure.
    ///      Uses vm.mockCallRevert to make WETH.deposit() fail during cleanup path.
    function test_DEP13_postDeployCallFails_bubblesRevert() public {
        // Test parameters - use unique root to get unique CREATE2 address
        bytes32 root = keccak256("dep13_root");
        address initialOwner = address(0xDEAD);

        // Compute the CREATE2 address where proxy will be deployed
        // Salt derivation: salt = keccak256(abi.encodePacked(root, initialOwner))
        bytes32 salt = keccak256(abi.encodePacked(root, initialOwner));

        // Initcode: hex"60253d8160093d39f33d3d3d3d363d3d37363d6c" ++ bytes13(uint104(factory)) ++ hex"5af43d3d93803e602357fd5bf3"
        bytes memory initcode = abi.encodePacked(
            hex"60253d8160093d39f33d3d3d3d363d3d37363d6c",
            bytes13(uint104(uint160(address(factory)))),
            hex"5af43d3d93803e602357fd5bf3"
        );
        bytes32 initcodeHash = keccak256(initcode);

        // CREATE2 address = keccak256(0xff ++ factory ++ salt ++ keccak256(initcode))[12:]
        address predictedProxy = address(
            uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(factory), salt, initcodeHash))))
        );

        // Pre-fund the CREATE2 address with ETH so cleanup() will attempt to wrap
        vm.deal(predictedProxy, 1 ether);
        assertEq(predictedProxy.balance, 1 ether, "Pre-funding should succeed");

        // Mock WETH.deposit() to revert with a specific error
        // cleanup() calls WETH with value (deposit via fallback), which should revert
        bytes memory mockRevertData = abi.encodeWithSignature("MockWethFailed()");
        vm.mockCallRevert(address(WETH), 1 ether, bytes(""), mockRevertData);

        // Deploy with setOwnerNotCleanup=false, which triggers cleanup(proxy)
        // cleanup() sees balance != 0, tries to wrap via WETH, which reverts
        // deploy() reverts with empty data from cleanup()
        vm.expectRevert();
        factory.deploy(root, false, initialOwner);

        // Clear the mock for subsequent tests
        vm.clearMockedCalls();
    }

    /// @notice PAT-06: token.balanceOf reverts - bubbles revert
    function test_PAT06_balanceOfReverts_bubbles() public {
        uint256 ownerKey = uint256(keccak256("pat06_owner"));
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat06_action"), ownerKey);

        address revertingToken = address(0xDEADBEEF);
        vm.etch(revertingToken, hex"60006000fd");

        bytes memory data = abi.encodeWithSignature("someFunction(uint256)", uint256(0));

        vm.prank(owner);
        vm.expectRevert();
        proxy.call(payable(address(0x1234)), IERC20(revertingToken), 500000, 4, data);
    }

    /// @notice PAT-07: token.balanceOf returns < 32 bytes - reverts
    function test_PAT07_balanceOfShortReturn_reverts() public {
        uint256 ownerKey = uint256(keccak256("pat07_owner"));
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("pat07_action"), ownerKey);

        bytes memory shortReturnCode = hex"600f6000526010600ff3";
        address shortReturnToken;
        assembly {
            shortReturnToken := create(0, add(shortReturnCode, 0x20), mload(shortReturnCode))
        }
        require(shortReturnToken != address(0), "Failed to deploy short return token");

        bytes memory data = abi.encodeWithSignature("someFunction(uint256)", uint256(0));

        vm.prank(owner);
        vm.expectRevert();
        proxy.call(payable(address(0x1234)), IERC20(shortReturnToken), 500000, 4, data);
    }

    /// @notice CTX-04: short multicall calldata keeps msg.sender
    /// @dev Exercise the <=3-byte path via empty data + value.
    function test_CTX04_multicallShortData_returnsMsgSender() public {
        uint256 ownerKey = uint256(keccak256(abi.encode("ctx04_owner")));
        (ICrossChainReceiverFactory proxy,) =
            _deployProxy(keccak256(abi.encode("ctx04")), ownerKey);

        uint256 sendValue = 0.5 ether;
        vm.deal(EIP150_MULTICALL_ADDRESS, sendValue);

        uint256 wethBefore = WETH.balanceOf(address(proxy));

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = address(proxy);
        calls[0].data = "";
        calls[0].value = sendValue;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.REVERT;

        vm.prank(EIP150_MULTICALL_ADDRESS);
        IMultiCall.Result[] memory results = IMultiCall(payable(EIP150_MULTICALL_ADDRESS)).multicall{value: sendValue}(calls, 0);

        assertTrue(results[0].success, "Call with short data should succeed");

        uint256 wethAfter = WETH.balanceOf(address(proxy));
        assertEq(wethAfter - wethBefore, sendValue, "Proxy should have wrapped the ETH to WETH");
    }

    /// @notice SIG-12: signature.length == 64 exactly depends on content parsing
    function test_SIG12_64ByteSignature_dependsOnContent() public {
        uint256 ownerKey = uint256(keccak256("sig12_owner"));
        (ICrossChainReceiverFactory proxy, address owner) = _deployProxy(keccak256("sig12_action"), ownerKey);

        // 64-byte boundary: clean first word forces Merkle path; offset=64 yields empty proof.
        bytes memory sig = abi.encodePacked(
            bytes32(uint256(uint160(owner))), // 32 bytes: clean padded address
            bytes32(uint256(64))              // 32 bytes: offset = 64 (points past signature)
        );
        assertEq(sig.length, 64, "Signature should be exactly 64 bytes");

        bytes32 arbitraryHash = keccak256("test hash");

        bytes4 result = proxy.isValidSignature(arbitraryHash, sig);
        assertEq(result, INVALID_SIG, "Should return INVALID_SIG for invalid Merkle proof");
    }


    // =========================================================================
    // getFromMulticall() Tests (GFM)
    // =========================================================================

    /// @notice GFM-05: balanceOf(EIP150_MULTICALL_ADDRESS) returns balance == 0 - breaks early, returns true
    function test_GFM05_erc20BalanceZero_returnsEarlyWithTrue() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("gfm05"));

        address mockToken = address(uint160(uint256(keccak256("gfm05_token"))));
        vm.etch(mockToken, hex"00");

        vm.mockCall(
            mockToken,
            abi.encodeWithSelector(IERC20.balanceOf.selector, EIP150_MULTICALL_ADDRESS),
            abi.encode(uint256(0))
        );

        address payable recipient = payable(address(0xBEEF));
        bool result = proxy.getFromMulticall(IERC20(mockToken), recipient);

        assertTrue(result, "Should return true even with 0 balance");
    }

    /// @notice INT-31: calling getFromMulticall twice (first drains, second no-op) returns true
    function test_INT31_multipleGetFromMulticallCalls_bothSucceed() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("int31"));

        uint256 testAmount = 1 ether;
        vm.deal(EIP150_MULTICALL_ADDRESS, testAmount);

        address payable recipient = payable(address(0xBEEF));
        uint256 recipientBalanceBefore = recipient.balance;

        bool result1 = proxy.getFromMulticall(NATIVE, recipient);

        assertTrue(result1, "First call should succeed");
        assertEq(recipient.balance, recipientBalanceBefore + testAmount, "Recipient should receive ETH");
        assertEq(EIP150_MULTICALL_ADDRESS.balance, 0, "MULTICALL should be drained");

        address rejectingContract = address(new RejectingContract());
        bool result2 = proxy.getFromMulticall(NATIVE, payable(rejectingContract));

        assertTrue(result2, "Second call should succeed with zero balance");
        assertEq(EIP150_MULTICALL_ADDRESS.balance, 0, "MULTICALL should remain drained");
    }

    /// @notice GFM-06: balanceOf(EIP150_MULTICALL_ADDRESS) reverts - bubbles revert
    function test_GFM06_erc20BalanceOfReverts_bubblesRevert() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("gfm06"));

        address mockToken = address(uint160(uint256(keccak256("gfm06_token"))));
        vm.etch(mockToken, hex"00");

        vm.mockCallRevert(
            mockToken,
            abi.encodeWithSelector(IERC20.balanceOf.selector, EIP150_MULTICALL_ADDRESS),
            "BALANCE_QUERY_FAILED"
        );

        address payable recipient = payable(address(0xBEEF));

        vm.expectRevert("BALANCE_QUERY_FAILED");
        proxy.getFromMulticall(IERC20(mockToken), recipient);
    }

    /// @notice GFM-08: multicall transfer succeeds - returns true, tokens sent to recipient
    function test_GFM08_erc20MulticallTransferSucceeds_returnsTrueTokensSent() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("gfm08"));

        uint256 testAmount = 2 ether;
        vm.deal(EIP150_MULTICALL_ADDRESS, testAmount);

        IMultiCall.Call[] memory wrapCalls = new IMultiCall.Call[](1);
        wrapCalls[0] = IMultiCall.Call({
            target: address(WETH),
            revertPolicy: IMultiCall.RevertPolicy.REVERT,
            value: testAmount,
            data: abi.encodeWithSignature("deposit()")
        });
        IMultiCall(payable(EIP150_MULTICALL_ADDRESS)).multicall{value: testAmount}(wrapCalls, 0);

        address payable recipient = payable(address(0xDEAD));
        bool result = proxy.getFromMulticall(WETH, recipient);

        assertTrue(result, "Should return true");
        assertEq(WETH.balanceOf(recipient), testAmount, "Recipient should receive exact WETH amount");
        assertEq(WETH.balanceOf(EIP150_MULTICALL_ADDRESS), 0, "MULTICALL should have 0 WETH after");
    }

    /// @notice GFM-16: multicall send fails (recipient rejects ETH) - bubbles revert
    function test_GFM16_nativeMulticallSendFails_bubblesRevert() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("gfm16"));

        uint256 testAmount = 1 ether;
        vm.deal(EIP150_MULTICALL_ADDRESS, testAmount);

        address rejectingContract = address(new RejectingContract());

        vm.expectRevert();
        proxy.getFromMulticall(NATIVE, payable(rejectingContract));
    }

    /// @notice GFM-09: multicall transfer fails (insufficient balance race) - bubbles revert
    function test_GFM09_erc20MulticallTransferFails_bubblesRevert() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("gfm09"));

        address mockToken = address(uint160(uint256(keccak256("gfm09_token"))));
        vm.etch(mockToken, hex"00");

        vm.mockCall(
            mockToken,
            abi.encodeWithSelector(IERC20.balanceOf.selector, EIP150_MULTICALL_ADDRESS),
            abi.encode(100 ether)
        );

        vm.mockCallRevert(
            mockToken,
            abi.encodeWithSelector(IERC20.transfer.selector),
            "INSUFFICIENT_BALANCE"
        );

        address payable recipient = payable(address(0xBEEF));

        vm.expectRevert();
        proxy.getFromMulticall(IERC20(mockToken), recipient);
    }

    /// @notice GFM-26: balanceOf returns success but empty (0 bytes)
    function test_GFM26_balanceOfReturnsEmpty_shouldRevert() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("gfm26"));

        address mockToken = address(uint160(uint256(keccak256("gfm26_token"))));

        bytes memory emptyReturnBytecode = hex"60006000f3";
        vm.etch(mockToken, emptyReturnBytecode);

        address payable recipient = payable(address(0xBEEF));

        vm.expectRevert();
        proxy.getFromMulticall(IERC20(mockToken), recipient);
    }

    // =========================================================================
    // HMC: _hashMultiCall bounds checks
    // =========================================================================

    /// @notice HMC-13: calls array offset >= 2^64 causes revert
    function test_HMC13_callsArrayOffset_exceedsUint64_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc13"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(1 << 64),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0xa0),
            uint256(0),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success, bytes memory returndata) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert with offset >= 2^64");
        assertEq(returndata.length, 0, "Bounds check revert has empty data");
    }

    /// @notice HMC-14: calls array offset points past calldata end
    function test_HMC14_callsArrayOffset_pastCalldataEnd_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc14"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0x1000),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0xa0),
            uint256(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert when calls offset past calldata end");
    }

    /// @notice HMC-15: calls array length >= 2^59 causes revert
    function test_HMC15_callsArrayLength_exceedsLimit_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc15"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0xc0),
            uint256(1 << 59),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert with calls length >= 2^59");
    }

    /// @notice HMC-16: calls array end exceeds calldata bounds
    function test_HMC16_callsArrayEnd_exceedsCalldata_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc16"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0xc0),
            uint256(100),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert when calls array end exceeds calldata");
    }

    /// @notice HMC-17: individual Call offset >= 2^64 causes revert
    function test_HMC17_callOffset_exceedsUint64_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc17"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0x100),
            uint256(1),
            uint256(1 << 64),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert with Call offset >= 2^64");
    }

    /// @notice HMC-18: individual Call struct extends past calldata
    function test_HMC18_callStruct_extendsPastCalldata_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc18"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0xe0),
            uint256(1),
            uint256(0x100),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert when Call struct extends past calldata");
    }

    /// @notice HMC-19: Call.data offset >= 2^64 causes revert
    function test_HMC19_callDataOffset_exceedsUint64_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc19"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0x180),
            uint256(1),
            uint256(0x20),
            address(0xBEEF),
            uint256(0),
            uint256(0),
            uint256(1 << 64),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert with Call.data offset >= 2^64");
    }

    /// @notice HMC-20: Call.data pointer exceeds calldata bounds
    function test_HMC20_callDataPointer_exceedsCalldata_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc20"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0x180),
            uint256(1),
            uint256(0x20),
            address(0xBEEF),
            uint256(0),
            uint256(0),
            uint256(0x1000),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert when Call.data pointer exceeds calldata");
    }

    /// @notice HMC-21: Call.data length >= 2^64 causes revert
    function test_HMC21_callDataLength_exceedsUint64_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc21"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0x1a0),
            uint256(1),
            uint256(0x20),
            address(0xBEEF),
            uint256(0),
            uint256(0),
            uint256(0x80),
            uint256(1 << 64),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert with Call.data length >= 2^64");
    }

    /// @notice HMC-22: Call.data end exceeds calldata bounds
    function test_HMC22_callDataEnd_exceedsCalldata_reverts() public {
        (ICrossChainReceiverFactory proxy,) = _deployProxy(keccak256("hmc22"));

        bytes memory malformedCalldata = abi.encodePacked(
            bytes4(0x0d899f68),
            uint256(0xa0),
            uint256(0),
            uint256(1),
            uint256(block.timestamp + 1000),
            uint256(0x1a0),
            uint256(1),
            uint256(0x20),
            address(0xBEEF),
            uint256(0),
            uint256(0),
            uint256(0x80),
            uint256(1000),
            bytes32(uint256(0xDEADBEEF)),
            uint256(0x40),
            bytes32(0),
            bytes32(0)
        );

        (bool success,) = address(proxy).call(malformedCalldata);
        assertFalse(success, "Should revert when Call.data end exceeds calldata");
    }

    // =========================================================================
    // MWN - Missing WNATIVE Chain Support Tests
    // =========================================================================

    /// @notice MWN-01: deploy factory with `_WNATIVE == address(0)` and correct codehash
    function test_MWN01_factoryDeployWithMissingWnative_succeeds() public {
        _deployMissingWnativeFactory();

        assertGt(address(missingWnativeFactory).code.length, 0, "Factory should have code");

        assertEq(
            address(missingWnativeFactory),
            address(0x00000000000000AaBbCcDdEEfF11223344556677),
            "Factory address mismatch"
        );
    }

    /// @notice MWN-02: `_HAS_WNATIVE` == false after deployment
    function test_MWN02_hasWnativeFalse_proxyAcceptsEthWithoutWrap() public {
        _deployMissingWnativeFactory();

        uint256 sendAmount = 1 ether;

        uint256 missingOwnerKey = uint256(keccak256(abi.encode("mwn02_missing_owner")));
        (ICrossChainReceiverFactory missingProxy,) =
            _deployProxyMissingWnative(keccak256("mwn02_missing"), missingOwnerKey, true);

        vm.deal(address(this), sendAmount);
        (bool success2,) = address(missingProxy).call{value: sendAmount}("");
        assertTrue(success2, "Missing WNATIVE proxy should accept ETH");

        assertEq(address(missingProxy).balance, sendAmount, "Missing WNATIVE proxy should hold raw ETH");
    }

    /// @notice MWN-03: `_MISSING_WNATIVE` == true after deployment
    function test_MWN03_missingWnativeTrue_deployForcesSetsOwner() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256(abi.encode("mwn03_owner")));
        address owner = vm.addr(ownerKey);
        bytes32 root = keccak256("mwn03");

        ICrossChainReceiverFactory proxy = missingWnativeFactory.deploy(root, false, owner);

        assertGt(address(proxy).code.length, 0, "Proxy should persist when _MISSING_WNATIVE is true");

        assertEq(proxy.owner(), owner, "Owner should be set despite setOwner=false");
    }

    /// @notice MWN-04: constructor skips WETH behavioral checks when WNATIVE is missing
    /// @dev Force address(0) calls to revert to prove constructor doesn't touch WETH.
    function test_MWN04_missingWnative_constructorSkipsWethChecks() public {
        bytes memory originalWnativeCode = wnativeStorage.code;

        vm.etch(wnativeStorage, MISSING_WNATIVE_BYTECODE);
        require(wnativeStorage.codehash == MISSING_WNATIVE_CODEHASH, "Missing WNATIVE codehash mismatch");

        vm.mockCallRevert(address(0), bytes(""), bytes("WNATIVE_CALLED_UNEXPECTEDLY"));

        vm.chainId(31337);
        ICrossChainReceiverFactory testFactory =
            ICrossChainReceiverFactory(payable(address(0x00000000000000BbCcDdEeFf00112233445566)));
        vm.setNonce(address(testFactory), 1);
        vm.startPrank(TOEHOLD);
        deployCodeTo("CrossChainReceiverFactory.sol", "", 0, address(testFactory));
        vm.stopPrank();

        vm.clearMockedCalls();
        vm.etch(wnativeStorage, originalWnativeCode);

        assertGt(address(testFactory).code.length, 0, "Factory should have code");
    }
    /// @notice MWN-09: approvePermit2(NATIVE) reverts when _MISSING_WNATIVE=true
    function test_MWN09_approvePermit2Native_revertsWhenMissingWnative() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256(abi.encode("mwn09_owner")));
        (ICrossChainReceiverFactory proxy,) = _deployProxyMissingWnative(keccak256("mwn09"), ownerKey, true);

        vm.expectRevert();
        proxy.approvePermit2(NATIVE, type(uint256).max);
    }

    /// @notice MWN-10: approvePermit2(ERC20) succeeds when _MISSING_WNATIVE=true
    function test_MWN10_approvePermit2ERC20_succeedsWhenMissingWnative() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256(abi.encode("mwn10_owner")));
        (ICrossChainReceiverFactory proxy,) = _deployProxyMissingWnative(keccak256("mwn10"), ownerKey, true);

        address mockToken = _deployMockERC20();

        proxy.approvePermit2(IERC20(mockToken), type(uint256).max);
    }

    /// @notice MWN-17: `_HAS_WNATIVE=false`, excess value recovery path works
    function test_MWN17_metaTx_excessValueRecovered_missingWnative() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256(abi.encode("mwn17_owner")));
        (ICrossChainReceiverFactory proxy,) = _deployProxyMissingWnative(keccak256("mwn17"), ownerKey, true);

        address revertingTarget = address(0xDEAD1177);
        vm.etch(revertingTarget, hex"60006000fd");

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0] = IMultiCall.Call({
            target: revertingTarget,
            revertPolicy: IMultiCall.RevertPolicy.CONTINUE,
            value: 0.5 ether,
            data: hex"deadbeef"
        });

        vm.deal(address(proxy), 1 ether);
        uint256 proxyBefore = address(proxy).balance;
        uint256 multicallBefore = address(EIP150_MULTICALL_ADDRESS).balance;

        uint256 nonce = 17;
        uint256 deadline = block.timestamp + 1000;
        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, 0, nonce, deadline);

        IMultiCall.Result[] memory results = proxy.metaTx(calls, 0, nonce, deadline, signature);
        assertEq(results.length, 1);
        assertFalse(results[0].success, "Call should fail but be recovered");

        assertEq(address(proxy).balance, proxyBefore + multicallBefore, "Proxy should recover excess ETH");
        assertEq(address(EIP150_MULTICALL_ADDRESS).balance, 0, "Multicall balance should be drained");
    }
    /// @notice MWN-18: cleanup via metaTx succeeds on missing WNATIVE chain
    function test_MWN18_cleanupViaMetaTx_missingWnative_succeeds() public {
        _deployMissingWnativeFactory();

        uint256 ownerKey = uint256(keccak256(abi.encode("mwn18_owner")));
        (ICrossChainReceiverFactory proxy,) = _deployProxyMissingWnative(keccak256("mwn18"), ownerKey, true);

        uint256 sendAmount = 0.2 ether;
        vm.deal(address(proxy), sendAmount);

        address payable beneficiary = payable(address(0x1818));
        uint256 beneficiaryBefore = beneficiary.balance;
        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0] = IMultiCall.Call({
            target: address(proxy),
            revertPolicy: IMultiCall.RevertPolicy.REVERT,
            value: 0,
            data: abi.encodeCall(ICrossChainReceiverFactory.cleanup, (beneficiary))
        });

        uint256 nonce = 18;
        uint256 deadline = block.timestamp + 1000;
        bytes memory signature = _signMetaTxSimple(ownerKey, address(proxy), calls, 0, nonce, deadline);

        proxy.metaTx(calls, 0, nonce, deadline, signature);
        assertEq(beneficiary.balance - beneficiaryBefore, sendAmount, "Beneficiary should receive ETH");
    }
    /// @notice MWN-23: codehash mismatch reverts constructor
    function test_MWN23_missingWnative_codehashMismatch_reverts() public {
        bytes memory originalWnativeCode = wnativeStorage.code;

        vm.etch(wnativeStorage, hex"00");
        assertTrue(wnativeStorage.codehash != MISSING_WNATIVE_CODEHASH, "Codehash should mismatch");

        address factoryAddr = address(0x00000000000000EeFf00112233445566778899);
        vm.chainId(31337);
        vm.setNonce(factoryAddr, 1);

        vm.startPrank(TOEHOLD);
        vm.expectRevert();
        deployCodeTo("CrossChainReceiverFactory.sol", "", 0, factoryAddr);
        vm.stopPrank();

        vm.etch(wnativeStorage, originalWnativeCode);
    }

    // =========================================================================
    // EIP-150 ratio helper checks
    // =========================================================================

    /// @notice Derive contract address from deployer and nonce
    function _deriveEIP150Address(address deployer, uint8 nonce) internal pure returns (address result) {
        assembly ("memory-safe") {
            mstore(0x14, deployer)
            mstore(0x00, 0xd694)
            mstore8(0x34, nonce)
            result := shr(96, shl(96, keccak256(0x1e, 0x17)))
        }
    }

    function _eip150InvalidTarget() internal view returns (address) {
        return _deriveEIP150Address(address(factory), 1);
    }

    /// @notice EIP150-01: Verify INVALID target contract exists at nonce 1 with correct bytecode
    function test_EIP150_01_invalidTarget_deployedWithCorrectBytecode() public view {
        address invalidTarget = _eip150InvalidTarget();

        uint256 codeSize = invalidTarget.code.length;
        assertEq(codeSize, 1, "INVALID target should be exactly 1 byte");

        bytes memory code = invalidTarget.code;
        assertEq(uint8(code[0]), 0xfe, "INVALID target should contain INVALID opcode");
    }

    /// @notice EIP150-04: Calling INVALID target with CONTINUE policy reverts due to OOG protection
    /// @dev INVALID consumes all gas, so MultiCall's OOG protection forces a revert.
    function test_EIP150_04_invalidTarget_multicallWithContinue_revertsOOG() public {
        address invalidTarget = _eip150InvalidTarget();

        IMultiCall.Call[] memory calls = new IMultiCall.Call[](1);
        calls[0].target = invalidTarget;
        calls[0].revertPolicy = IMultiCall.RevertPolicy.CONTINUE;

        bytes memory data = abi.encodeCall(IMultiCall.multicall, (calls, 0));
        (bool success,) = EIP150_MULTICALL_ADDRESS.call{gas: 200_000}(data);

        assertFalse(success, "Multicall should revert due to OOG protection");
    }
}

/// @notice Helper contract that rejects ETH transfers
contract RejectingContract {
    // No receive() or fallback() function - will reject ETH
}

/// @notice Helper contract to test noDelegateCall modifier
contract DelegateCallAttacker {
    address public factory;

    constructor(address _factory) {
        factory = _factory;
    }

    function tryDelegateCallDeploy(bytes32 root, bool setOwnerNotCleanup, address owner) external {
        bytes memory data = abi.encodeWithSignature("deploy(bytes32,bool,address)", root, setOwnerNotCleanup, owner);
        (bool success, bytes memory returnData) = factory.delegatecall(data);
        if (!success) {
            assembly {
                revert(add(returnData, 32), mload(returnData))
            }
        }
    }
}
