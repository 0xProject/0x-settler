// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

struct uint512 {
    uint256 hi;
    uint256 lo;
}

library Lib512Math {
    /// With optimization turned on, when used correctly, this function
    /// completely optimizes out and does not appear in the generated bytecode.
    function _deallocate(uint512 memory r) private pure {
        assembly ("memory-safe") {
            let ptr := sub(mload(0x40), 0x40)
            if iszero(eq(ptr, r)) { revert(0x00, 0x00) }
            mstore(0x40, ptr)
        }
    }

    function from(uint512 memory r, uint256 x) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            mstore(r, 0x00)
            mstore(add(0x20, r), x)
            r_out := r
        }
    }

    function from(uint512 memory r, uint256 x_hi, uint256 x_lo) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            mstore(r, x_hi)
            mstore(add(0x20, r), x_lo)
            r_out := r
        }
    }

    function into(uint512 memory x) internal pure returns (uint256 r_hi, uint256 r_lo) {
        assembly ("memory-safe") {
            r_hi := mload(x)
            r_lo := mload(add(0x20, x))
        }
    }

    function oadd(uint512 memory r, uint256 x, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let r_lo := add(x, y)
            let r_hi := lt(r_lo, x)

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function oadd(uint512 memory r, uint512 memory x, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let r_lo := add(x_lo, y)
            let r_hi := add(x_hi, lt(r_lo, x_lo))

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function iadd(uint512 memory r, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = oadd(r, r, y);
    }

    function oadd(uint512 memory r, uint512 memory x, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let y_hi := mload(y)
            let y_lo := mload(add(0x20, y))
            let r_lo := add(x_lo, y_lo)
            let r_hi := add(add(x_hi, y_hi), lt(r_lo, x_lo))

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function iadd(uint512 memory r, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = oadd(r, r, y);
    }

    function osub(uint512 memory r, uint512 memory x, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let r_lo := sub(x_lo, y)
            let r_hi := sub(x_hi, gt(y, x_lo))

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function isub(uint512 memory r, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = osub(r, r, y);
    }

    function osub(uint512 memory r, uint512 memory x, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let y_hi := mload(y)
            let y_lo := mload(add(0x20, y))
            let r_lo := sub(x_lo, y_lo)
            let r_hi := sub(sub(x_hi, y_hi), gt(y_lo, x_lo))

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function isub(uint512 memory r, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = osub(r, r, y);
    }

    function omul(uint512 memory r, uint256 x, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let mm := mulmod(x, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            let r_lo := mul(x, y)
            let r_hi := sub(sub(mm, r_lo), lt(mm, r_lo))

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function omul(uint512 memory r, uint512 memory x, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let mm := mulmod(x_lo, y, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            let r_lo := mul(x_lo, y)
            let r_hi := add(mul(x_hi, y), sub(sub(mm, r_lo), lt(mm, r_lo)))

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function imul(uint512 memory r, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = omul(r, r, y);
    }

    function omul(uint512 memory r, uint512 memory x, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        assembly ("memory-safe") {
            let y_hi := mload(y)
            let y_lo := mload(add(0x20, y))
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let mm := mulmod(x_lo, y_lo, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            let r_lo := mul(x_lo, y_lo)
            let r_hi := add(sub(sub(mm, r_lo), lt(mm, r_lo)), add(mul(x_hi, y_lo), mul(x_lo, y_hi)))

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function imul(uint512 memory r, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = omul(r, r, y);
    }

    function mod(uint512 memory n, uint256 d) internal pure returns (uint256 r) {
        assembly ("memory-safe") {
            let x_hi := mload(n)
            let x_lo := mload(add(0x20, n))
            r := mulmod(x_hi, sub(0x00, d), d)
            r := addmod(x_lo, r, d)
        }
    }

    function div(uint512 memory n, uint256 d) internal pure returns (uint256 q) {
        // This function is mostly stolen from Remco Bloemen https://2π.com/21/muldiv/ .
        // The original code was released under the MIT license.
        assembly ("memory-safe") {
            let n_hi := mload(n)
            let n_lo := mload(add(0x20, n))

            // Get the remainder [n_hi n_lo] % d (< 2²⁵⁶)
            // 2**256 % d = -d % 2**256 % d
            let rem := mulmod(n_hi, sub(0x00, d), d)
            rem := addmod(n_lo, rem, d)

            // Make division exact by rounding [n_hi n_lo] down to a multiple of d
            // Subtract 256-bit number from 512-bit number.
            n_hi := sub(n_hi, gt(rem, n_lo))
            n_lo := sub(n_lo, rem)

            // Factor powers of two out of the denominator
            {
                // Compute largest power of two divisor of the denominator
                // Always ≥ 1.
                let twos := and(sub(0x00, d), d)

                // Divide d by the power of two
                d := div(d, twos)

                // Divide [n_hi n_lo] by the power of two
                n_lo := div(n_lo, twos)
                // Shift in bits from n_hi into n_lo. For this we need to flip `twos`
                // such that it is 2²⁵⁶ / twos.
                //     2**256 / twos = -twos % 2**256 / twos + 1
                // If twos is zero, then it becomes one (not possible)
                let twosInv := add(div(sub(0x00, twos), twos), 0x01)
                n_lo := or(n_lo, mul(n_hi, twosInv))
            }

            // Invert the denominator mod 2²⁵⁶
            // Now that d is an odd number, it has an inverse modulo 2²⁵⁶ such
            // that d * inv ≡ 1 mod 2²⁵⁶.
            // We use Newton-Raphson iterations compute inv. Thanks to Hensel's
            // lifting lemma, this also works in modular arithmetic, doubling
            // the correct bits in each step. The Newton-Raphson-Hensel step is:
            //    inv_{n+1} = inv_n * (2 - d*inv_n) % 2**512

            // To kick off Newton-Raphson-Hensel iterations, we start with a
            // seed of the inverse that is correct correct for four bits.
            //     d * inv ≡ 1 mod 2⁴
            let inv := xor(mul(0x03, d), 0x02)

            // Each Newton-Raphson-Hensel step doubles the number of correct
            // bits in inv. After 6 iterations, full convergence is guaranteed.
            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2⁸
            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2¹⁶
            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2³²
            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2⁶⁴
            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2¹²⁸
            inv := mul(inv, sub(0x02, mul(d, inv))) // inverse mod 2²⁵⁶

            // Because the division is now exact (we subtracted the remainder at
            // the beginning), we can divide by multiplying with the modular
            // inverse of the denominator. This will give us the correct result
            // modulo 2²⁵⁶.
            q := mul(n_lo, inv)
        }
    }

    function odiv(uint512 memory r, uint512 memory x, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);

        // This function is mostly stolen from Remco Bloemen https://2π.com/21/muldiv/ .
        // The original code was released under the MIT license.
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))

            // Get the remainder [x_hi x_lo] % y (< 2²⁵⁶)
            // 2**256 % y = -y % 2**256 % y
            let rem := mulmod(x_hi, sub(0x00, y), y)
            rem := addmod(x_lo, rem, y)

            // Make division exact by rounding [x_hi x_lo] down to a multiple of y
            // Subtract 256-bit number from 512-bit number.
            x_hi := sub(x_hi, gt(rem, x_lo))
            x_lo := sub(x_lo, rem)

            // Factor powers of two out of the denominator
            {
                // Compute largest power of two divisor of the denominator
                // Always ≥ 1.
                let twos := and(sub(0x00, y), y)

                // Divide y by the power of two
                y := div(y, twos)

                // Divide [x_hi x_lo] by the power of two
                x_lo := div(x_lo, twos)
                // Shift in bits from x_hi into x_lo. For this we need to flip `twos`
                // such that it is 2²⁵⁶ / twos.
                //     2**256 / twos = -twos % 2**256 / twos + 1
                // If twos is zero, then it becomes one (not possible)
                let twosInv := add(div(sub(0x00, twos), twos), 0x01)
                x_lo := or(x_lo, mul(x_hi, twosInv))
                x_hi := div(x_hi, twos)
            }

            // Invert the denominator mod 2⁵¹²
            // Now that y is an odd number, it has an inverse modulo 2⁵¹² such
            // that y * inv ≡ 1 mod 2⁵¹².
            // We use Newton-Raphson iterations compute inv. Thanks to Hensel's
            // lifting lemma, this also works in modular arithmetic, doubling
            // the correct bits in each step. The Newton-Raphson-Hensel step is:
            //    inv_{n+1} = inv_n * (2 - y*inv_n) % 2**512

            // These are pure-Yul reimplementations of the corresponding
            // functions above. They're needed here as helper functions for
            // nrhStep.
            function mul256x256(a, b) -> o_hi, o_lo {
                let mm := mulmod(a, b, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
                o_lo := mul(a, b)
                o_hi := sub(sub(mm, o_lo), lt(mm, o_lo))
            }

            function mul512x256(a_hi, a_lo, b) -> o_hi, o_lo {
                o_hi, o_lo := mul256x256(a_lo, b)
                o_hi := add(mul(a_hi, b), o_hi)
            }

            function mul512x512(a_hi, a_lo, b_hi, b_lo) -> o_hi, o_lo {
                o_hi, o_lo := mul512x256(a_hi, a_lo, b_lo)
                o_hi := add(mul(a_lo, b_hi), o_hi)
            }

            // This is the Newton-Raphson-Hensel step:
            //    inv_{n+1} = inv_n * (2 - y*inv_n) % 2**512
            function nrhStep(a_hi, a_lo, b) -> o_hi, o_lo {
                o_hi, o_lo := mul512x256(a_hi, a_lo, b)
                o_hi := sub(sub(0x00, o_hi), gt(o_lo, 0x02))
                o_lo := sub(0x02, o_lo)
                o_hi, o_lo := mul512x512(a_hi, a_lo, o_hi, o_lo)
            }

            // To kick off Newton-Raphson-Hensel iterations, we start with a
            // seed of the inverse that is correct correct for four bits.
            //     y * inv ≡ 1 mod 2⁴
            let inv_hi, inv_lo := mul256x256(0x03, y)
            inv_lo := xor(0x02, inv_lo)

            // Each application of nrhStep doubles the number of correct bits in
            // inv. After 7 iterations, full convergence is guaranteed.
            // TODO: see if this is faster if the loop is re-rolled
            // TODO: can we go back to the "old", 256-bit version for all but the final step?
            inv_hi, inv_lo := nrhStep(inv_hi, inv_lo, y) // inverse mod 2⁸
            inv_hi, inv_lo := nrhStep(inv_hi, inv_lo, y) // inverse mod 2¹⁶
            inv_hi, inv_lo := nrhStep(inv_hi, inv_lo, y) // inverse mod 2³²
            inv_hi, inv_lo := nrhStep(inv_hi, inv_lo, y) // inverse mod 2⁶⁴
            inv_hi, inv_lo := nrhStep(inv_hi, inv_lo, y) // inverse mod 2¹²⁸
            inv_hi, inv_lo := nrhStep(inv_hi, inv_lo, y) // inverse mod 2²⁵⁶
            inv_hi, inv_lo := nrhStep(inv_hi, inv_lo, y) // inverse mod 2⁵¹²

            // Because the division is now exact (we subtracted the remainder at
            // the beginning), we can divide by multiplying with the modular
            // inverse of the denominator. This will give us the correct result
            // modulo 2⁵¹².
            let r_hi, r_lo := mul512x512(x_hi, x_lo, inv_hi, inv_lo)

            mstore(r, r_hi)
            mstore(add(0x20, r), r_lo)
            r_out := r
        }
    }

    function idiv(uint512 memory r, uint256 y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = odiv(r, r, y);
    }

    function odiv(uint512 memory r, uint512 memory x, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        revert("unimplemented");
    }

    function idiv(uint512 memory r, uint512 memory y) internal pure returns (uint512 memory r_out) {
        _deallocate(r_out);
        r_out = odiv(r, r, y);
    }

    function eq(uint512 memory x, uint256 y) internal pure returns (bool r) {
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            r := and(iszero(x_hi), eq(x_lo, y))
        }
    }

    function gt(uint512 memory x, uint256 y) internal pure returns (bool r) {
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            r := or(gt(x_hi, 0x00), gt(x_lo, y))
        }
    }

    function lt(uint512 memory x, uint256 y) internal pure returns (bool r) {
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            r := and(iszero(x_hi), lt(x_lo, y))
        }
    }

    function ne(uint512 memory x, uint256 y) internal pure returns (bool) {
        return !eq(x, y);
    }

    function ge(uint512 memory x, uint256 y) internal pure returns (bool) {
        return !lt(x, y);
    }

    function le(uint512 memory x, uint256 y) internal pure returns (bool) {
        return !gt(x, y);
    }

    function eq(uint512 memory x, uint512 memory y) internal pure returns (bool r) {
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let y_hi := mload(y)
            let y_lo := mload(add(0x20, y))
            r := and(eq(x_hi, y_hi), eq(x_lo, y_lo))
        }
    }

    function gt(uint512 memory x, uint512 memory y) internal pure returns (bool r) {
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let y_hi := mload(y)
            let y_lo := mload(add(0x20, y))
            r := or(gt(x_hi, y_hi), and(eq(x_hi, y_hi), gt(x_lo, y_lo)))
        }
    }

    function lt(uint512 memory x, uint512 memory y) internal pure returns (bool r) {
        assembly ("memory-safe") {
            let x_hi := mload(x)
            let x_lo := mload(add(0x20, x))
            let y_hi := mload(y)
            let y_lo := mload(add(0x20, y))
            r := or(lt(x_hi, y_hi), and(eq(x_hi, y_hi), lt(x_lo, y_lo)))
        }
    }

    function ne(uint512 memory x, uint512 memory y) internal pure returns (bool) {
        return !eq(x, y);
    }

    function ge(uint512 memory x, uint512 memory y) internal pure returns (bool) {
        return !lt(x, y);
    }

    function le(uint512 memory x, uint512 memory y) internal pure returns (bool) {
        return !gt(x, y);
    }
}

function tmp_uint512() pure returns (uint512 memory r) {
    assembly ("memory-safe") {
        let ptr := sub(mload(0x40), 0x40)
        if iszero(eq(ptr, r)) { revert(0x00, 0x00) }
        mstore(0x40, ptr)

        r := 0x00
    }
}

using Lib512Math for uint512 global;
